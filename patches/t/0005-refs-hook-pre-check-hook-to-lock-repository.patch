From 7e468880d0b97cdba04a5efed7bab00fd7fddee9 Mon Sep 17 00:00:00 2001
From: Jiang Xin <zhiyou.jx@alibaba-inc.com>
Date: Mon, 22 Oct 2018 18:17:11 +0800
Subject: [PATCH 5/7] refs-hook: pre-check hook to lock repository

Before write to repo, check if repo is locked. User can add a lock file
'agit-repo.lock' in repo dir or any parent directories, and if this file
exists, write to repo is denied.

`git-gc` and `git-pack-refs` are not affected, and will work as usual.

Add test cases in `t/t1491-repo-locked.sh`.

Signed-off-by: Jiang Xin <zhiyou.jx@alibaba-inc.com>
---
 Makefile                          |   1 +
 refs.c                            |   5 +
 refs/refs-internal.h              |   6 +
 refs/transaction-pre-check-hook.c |  74 ++++++++++
 t/t0901-repo-locked.sh            | 227 ++++++++++++++++++++++++++++++
 5 files changed, 313 insertions(+)
 create mode 100644 refs/transaction-pre-check-hook.c
 create mode 100755 t/t0901-repo-locked.sh

diff --git a/Makefile b/Makefile
index 61aadf3ce8..44c07af3bf 100644
--- a/Makefile
+++ b/Makefile
@@ -1030,6 +1030,7 @@ LIB_OBJS += refs/files-backend.o
 LIB_OBJS += refs/iterator.o
 LIB_OBJS += refs/packed-backend.o
 LIB_OBJS += refs/ref-cache.o
+LIB_OBJS += refs/transaction-pre-check-hook.o
 LIB_OBJS += refspec.o
 LIB_OBJS += remote.o
 LIB_OBJS += replace-object.o
diff --git a/refs.c b/refs.c
index 9db66e9955..7685d4b324 100644
--- a/refs.c
+++ b/refs.c
@@ -2187,6 +2187,11 @@ int ref_transaction_commit(struct ref_transaction *transaction,
 	struct ref_store *refs = transaction->ref_store;
 	int ret;
 
+	/* Perform pre-check for transaction (write-lock check, etc.) */
+	if (ref_transaction_pre_check_hook(transaction, err)) {
+		return -1;
+	}
+
 	switch (transaction->state) {
 	case REF_TRANSACTION_OPEN:
 		/* Need to prepare first. */
diff --git a/refs/refs-internal.h b/refs/refs-internal.h
index 69f93b0e2a..7ba330f65f 100644
--- a/refs/refs-internal.h
+++ b/refs/refs-internal.h
@@ -734,4 +734,10 @@ void base_ref_store_init(struct ref_store *refs, struct repository *repo,
  */
 struct ref_store *maybe_debug_wrap_ref_store(const char *gitdir, struct ref_store *store);
 
+/*
+ * pre-check hook run before transaction_commit, which may be used to check
+ * lock of repository.
+ */
+int ref_transaction_pre_check_hook(struct ref_transaction *, struct strbuf *);
+
 #endif /* REFS_REFS_INTERNAL_H */
diff --git a/refs/transaction-pre-check-hook.c b/refs/transaction-pre-check-hook.c
new file mode 100644
index 0000000000..9a156379a5
--- /dev/null
+++ b/refs/transaction-pre-check-hook.c
@@ -0,0 +1,74 @@
+#include "../cache.h"
+#include "refs-internal.h"
+
+#define AGIT_REPO_WRITE_LOCK_FILE "agit-repo.lock"
+
+/*
+ * If this pre_check_hook failed (return no zero), ref transaction is denied,
+ * and user cannot write to the repository.
+ */
+int ref_transaction_pre_check_hook(struct ref_transaction *transaction, struct strbuf *err) {
+	struct strbuf dir_buf = STRBUF_INIT;
+	struct strbuf lock_file = STRBUF_INIT;
+	static int run_once = 0;
+	static int ret = 0;
+	char *dir;
+	int fd;
+	int len;
+	int loop = 0;
+	char err_msg[1024];
+	char *env;
+
+	if (run_once++) {
+		if (ret) {
+			strbuf_addstr(err, "repository is locked");
+		}
+		return ret;
+	}
+
+	env = getenv("GIT_REFS_TXN_NO_HOOK");
+	if ((env && !strcmp(env, "1")) || transaction->nr == 0)
+		return 0;
+
+	if (!the_repository->gitdir)
+		return 0;
+
+	strbuf_addstr(&dir_buf, absolute_path(the_repository->gitdir));
+	dir = dir_buf.buf;
+	while (1) {
+		loop++;
+		strbuf_reset(&lock_file);
+
+		if (!strcmp(dir, "/"))
+			strbuf_addstr(&lock_file, "/" AGIT_REPO_WRITE_LOCK_FILE);
+		else
+			strbuf_addf(&lock_file, "%s/%s", dir, AGIT_REPO_WRITE_LOCK_FILE);
+
+		if (!access(lock_file.buf, F_OK)) {
+			strbuf_addf(err, "cannot write to repository, locked by file '%s'.\n\n", AGIT_REPO_WRITE_LOCK_FILE);
+			ret = 1;
+			fd = open(lock_file.buf, O_RDONLY);
+			if (fd != -1) {
+				while ((len = read(fd, err_msg, 1024)) > 0) {
+					strbuf_add(err, err_msg, len);
+				}
+				close(fd);
+			}
+			break;
+		}
+
+		if (!strcmp(dir, "/"))
+			break;
+
+		if (loop > 20) {
+			break;
+		}
+
+		dir = dirname(dir);
+	}
+
+	strbuf_release(&dir_buf);
+	strbuf_release(&lock_file);
+
+	return ret;
+}
diff --git a/t/t0901-repo-locked.sh b/t/t0901-repo-locked.sh
new file mode 100755
index 0000000000..22083db2c0
--- /dev/null
+++ b/t/t0901-repo-locked.sh
@@ -0,0 +1,227 @@
+#!/bin/sh
+#
+# Copyright (c) 2018 Jiang Xin
+#
+
+test_description='Test repository lock by pre-check-hook for ref_transaction_commit'
+
+GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME=main
+export GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME
+
+. ./test-lib.sh
+
+m=refs/heads/main
+topic=refs/heads/topic
+bare=a/b/c/bare-repo.git
+lockfile=agit-repo.lock
+
+create_bare_repo () {
+	test "$#" = 1 ||
+	BUG "not 1 parameter to test-create-repo"
+	repo="$1"
+	mkdir -p "$repo"
+	(
+		cd "$repo" || error "Cannot setup test environment"
+		git -c \
+			init.defaultBranch="${GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME-master}" \
+			init --bare \
+			"--template=$GIT_BUILD_DIR/templates/blt/" >&3 2>&4 ||
+		error "cannot run git init -- have you built things yet?"
+		mv hooks hooks-disabled &&
+		git config core.abbrev 7
+	) || exit
+}
+
+create_commits_in () {
+	repo="$1" &&
+	if ! parent=$(git -C "$repo" rev-parse HEAD^{} 2>/dev/null)
+	then
+		parent=
+	fi &&
+	T=$(git -C "$repo" write-tree) &&
+	shift &&
+	while test $# -gt 0
+	do
+		name=$1 &&
+		test_tick &&
+		if test -z "$parent"
+		then
+			oid=$(echo $name | git -C "$repo" commit-tree $T)
+		else
+			oid=$(echo $name | git -C "$repo" commit-tree -p $parent $T)
+		fi &&
+		suffix=${oid#???????} &&
+		eval $name=$oid &&
+		parent=$oid &&
+		shift ||
+		return 1
+	done &&
+	env GIT_REFS_TXN_NO_HOOK=1 \
+		git -C "$repo" update-ref $m $oid
+}
+
+# Format the output of git-push, git-show-ref and other commands to make a
+# user-friendly and stable text.  We can easily prepare the expect text
+# without having to worry about future changes of the commit ID and spaces
+# of the output.  Single quotes are replaced with double quotes, because
+# it is boring to prepare unquoted single quotes in expect text.  We also
+# remove some locale error messages. The emitted human-readable errors are
+# redundant to the more machine-readable output the tests already assert.
+make_user_friendly_and_stable_output () {
+	sed \
+		-e "s/${A:-undef_rev}/<COMMIT-A>/g" \
+		-e "s/${B:-undef_rev}/<COMMIT-B>/g" \
+		-e "s/${C:-undef_rev}/<COMMIT-C>/g" \
+		-e "s/${D:-undef_rev}/<COMMIT-D>/g" \
+		-e "s/${E:-undef_rev}/<COMMIT-E>/g" \
+		-e "s/${F:-undef_rev}/<COMMIT-F>/g" \
+		-e "s/${H:-undef_rev}/<COMMIT-H>/g" \
+		-e "s/${I:-undef_rev}/<COMMIT-I>/g" \
+		-e "s/${J:-undef_rev}/<COMMIT-J>/g" \
+		-e "s/${K:-undef_rev}/<COMMIT-K>/g" \
+		-e "s/${TAG1_0:-undef_rev}/<TAG-1-0>/g" \
+		-e "s/${TAG1_1:-undef_rev}/<TAG-1-1>/g" \
+		-e "s/${TAG1_2:-undef_rev}/<TAG-1-2>/g" \
+		-e "s/${TAG1_3:-undef_rev}/<TAG-1-3>/g"
+}
+
+test_expect_success setup '
+	create_bare_repo "$bare" &&
+	create_commits_in "$bare" A B C D E F
+'
+
+test_expect_success "create repo with lock and fail to update-ref (locked)" '
+	(
+		cd "$bare" &&
+		printf "lock for maintainance." >$lockfile &&
+		test_must_fail git update-ref "$m" "$A" 2>&1
+	) >actual &&
+	cat >expect <<-EOF &&
+	fatal: update_ref failed for ref '"'"'refs/heads/main'"'"': cannot write to repository, locked by file '"'"'agit-repo.lock'"'"'.
+
+	lock for maintainance.
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success "update main (bypass locked with env)" '
+	(
+		cd "$bare" &&
+		test -f $lockfile &&
+		env GIT_REFS_TXN_NO_HOOK=1 git update-ref $m $A &&
+		git show-ref
+	) >out &&
+	make_user_friendly_and_stable_output <out >actual &&
+	cat >expect<<-EOF &&
+	<COMMIT-A> refs/heads/main
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success "pack-refs works even with lock" '
+	(
+		cd "$bare" &&
+		test -f refs/heads/main &&
+		git pack-refs --all &&
+		test ! -f refs/heads/main
+	)
+'
+
+test_expect_success "move lock file to upper dir" '
+	mv "$bare/$lockfile" "$lockfile"
+'
+
+test_expect_success "cannot create tag (locked)" '
+	(
+		cd "$bare" &&
+		test ! -f $lockfile &&
+		test -f "$HOME/$lockfile" &&
+		test_must_fail git tag -m v1.0 v1.0 refs/heads/main 2>&1
+	) >actual &&
+	cat >expect <<-EOF &&
+	fatal: cannot write to repository, locked by file '"'"'agit-repo.lock'"'"'.
+	
+	lock for maintainance.
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success "create tag with env, and gc works with lock" '
+	(
+		cd "$bare" &&
+		test_tick &&
+		env GIT_REFS_TXN_NO_HOOK=1 git tag -m v1.0 v1.0 refs/heads/main &&
+		test -f refs/tags/v1.0 &&
+		git gc -q &&
+		test ! -f refs/tags/v1.0
+	)
+'
+
+test_expect_success "clone and create local branches/tags (set env to bypass)" '
+	env GIT_REFS_TXN_NO_HOOK=1 git clone --no-local "$bare" work &&
+	create_commits_in work H I J K &&
+	(
+		cd work &&
+		test_tick &&
+		env GIT_REFS_TXN_NO_HOOK=1 git tag -m v1.1 v1.1 $H &&
+		env GIT_REFS_TXN_NO_HOOK=1 git tag -m v1.2 v1.2 $I &&
+		env GIT_REFS_TXN_NO_HOOK=1 git tag -m v1.3 v1.3 $J &&
+		env GIT_REFS_TXN_NO_HOOK=1 git branch dev $K
+	)
+'
+
+test_expect_success "set variables for tags" '
+	eval TAG1_0=$(git -C work rev-parse v1.0) &&
+	eval TAG1_1=$(git -C work rev-parse v1.1) &&
+	eval TAG1_2=$(git -C work rev-parse v1.2) &&
+	eval TAG1_3=$(git -C work rev-parse v1.3)
+'
+
+test_expect_success "fail to push one ref" '
+	(
+		cd work &&
+		test_must_fail git push origin v1.1 2>&1
+	) >out &&
+	grep -q "remote: lock for maintainance." out
+'
+
+test_expect_success "fail to push multiple refs" '
+	(
+		cd work &&
+		test_must_fail git push origin v1.1 v1.2 v1.3 dev
+	) &&
+	(
+		cd "$bare" &&
+		git show-ref
+	) >out &&
+	make_user_friendly_and_stable_output <out >actual &&
+	cat >expect<<-EOF &&
+	<COMMIT-A> refs/heads/main
+	<TAG-1-0> refs/tags/v1.0
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success "no lock, push ok" '
+	rm "$lockfile" &&
+	(
+		cd work &&
+		git push origin v1.1 v1.2 v1.3 dev
+	) &&
+	(
+		cd "$bare" &&
+		git show-ref
+	) >out &&
+	make_user_friendly_and_stable_output <out >actual &&
+	cat >expect<<-EOF &&
+	<COMMIT-K> refs/heads/dev
+	<COMMIT-A> refs/heads/main
+	<TAG-1-0> refs/tags/v1.0
+	<TAG-1-1> refs/tags/v1.1
+	<TAG-1-2> refs/tags/v1.2
+	<TAG-1-3> refs/tags/v1.3
+	EOF
+	test_cmp expect actual
+'
+
+test_done
-- 
patchwork
