From 6f95ee73b5f70596c650f704437ad2a7607b1fb8 Mon Sep 17 00:00:00 2001
From: "bojun.cbj" <bojun.cbj@alibaba-inc.com>
Date: Tue, 11 Feb 2020 15:37:57 +0800
Subject: [PATCH] agit-txn: push transactions for multiple replicas

Galileo project has a coordinator which coordinates the push operation
on multiple replicas for one repository. The redesigned push protocol
makes it easy for coordinating the replicas.

Steps added for the push protocol:

1. After sending commands and packfile, but before moving the packfile
   from the quarantine, "receive-pack" will ask for "prepare" signal
   from the coordinator.

2. After receive the "prepare" response from the coordinator,
   "receive-pack" marked as agit_main_instance (returned from "prepare"
   reponse), will execute the "proc-receive" hook.

3. Before update the references (run `execute_commands()`), as for
   "commit" signal from the coordnator.

4. Only one replica get the "agit_main_instance" flag from the "commit"
   response from the coordnator. Replicas marks as "agit_main_instance"
   will execute the "post-receive" hook.

Reqests from "receive-pack" to Galileo:

    agit-txn-req-prepare: Which is called right after "pre-receive" hook,
        but before moving the packfile sent by user from a temporary
        directory to git objects directory.  "receive-pack" will execute
        the "proc-receive" hook in this stage.

        A flush packet will be sent after this directive.

    agit-txn-req-commit: Which is called before executing the commands
        (create, update, delete references).  Galileo should create a
        distributed lock before sending respose to "receive-pack".

        A flush packet will be sent after this directive.

    agit-txn-req-end: This directive terminate the session between
        "receive-pack" and Galileo.  An optional checksum and error
        message may send before the flush packet. Example:

        PKT-LINE("agit-txn-req-end")
        PKT-LINE("checksum e9c022ff72cf02c8afb901e6d308d05e")
        PKT-LINE("error pre-receive hook decliend")
        FLUSH-PKT

Response from Galileo to "receive-pack":

    agit-txn-resp-next: Let "receive-pack" continue its process.
        It has one optional parameter (0, or 1).  Default 0,  if
        not parameter is given. The given parameter 1, will
        appoint "receive-pack" as the main instance.  A main
        instance in the "prepare" stage, will execute the
        "execute-commands" hook, and in the "commit" stage, will
        execute the "post-receive" hook.

        A flush packet will be given after this directive.

    agit-txn-resp-quit: Let "receive-pack" stop its process, and
        mark all the commands failed.

        A flush packet will be given after this directive.

EDIT:

 * [Jiang Xin, 2022-09-02] mkfifo is missing on Windows, so we add preq
   PIPE for each testcase, so we can bypass these testcases on Windows.

Helped-by: Jiang Xin <zhiyou.jx@alibaba-inc.com>
Signed-off-by: bojun.cbj <bojun.cbj@alibaba-inc.com>
Signed-off-by: Jiang Xin <zhiyou.jx@alibaba-inc.com>
---
 builtin/receive-pack.c      | 264 +++++++++++++++++++++++++++++++++++-
 t/t0932-agit-receive-txn.sh | 246 +++++++++++++++++++++++++++++++++
 2 files changed, 503 insertions(+), 7 deletions(-)
 create mode 100755 t/t0932-agit-receive-txn.sh

diff --git a/builtin/receive-pack.c b/builtin/receive-pack.c
index 9aabffa1af..f259cc869d 100644
--- a/builtin/receive-pack.c
+++ b/builtin/receive-pack.c
@@ -69,6 +69,15 @@ static int auto_update_server_info;
 static int auto_gc = 1;
 static int reject_thin;
 static int stateless_rpc;
+/* If agit_txn mode is enabled, our proxy server (galileo) will write
+ * three copies parallel, and will execute some hooks (such as
+ * "post-receive" and "execute-commands" which upstream has renamed to
+ * "proc-receive") for multiple times.  Galileo can appoint main instance
+ * by our extend protocol, and only execute these hooks if this
+ * 'receive-pack' is the main instance.
+ **/
+static int agit_txn;
+static int agit_main_instance = 0;
 static const char *service_dir;
 static const char *head_name;
 static void *head_name_to_free;
@@ -111,6 +120,55 @@ static struct proc_receive_ref {
 
 static void proc_receive_ref_append(const char *prefix);
 
+/*
+ * Reqests from "receive-pack" to Galileo:
+ *
+ *     agit-txn-req-prepare: Which is called right after "pre-receive" hook,
+ *         but before moving the packfile sent by user from a temporary
+ *         directory to git objects directory.  "receive-pack" will execute
+ *         the "execute-commands" hook ("proc-receive" hook in upstream) in
+ *         this stage.
+ *
+ *         A flush packet will be sent after this directive.
+ *
+ *     agit-txn-req-commit: Which is called before executing the commands
+ *         (create, update, delete references).  Galileo should create a
+ *         distributed lock before sending respose to "receive-pack".
+ *
+ *         A flush packet will be sent after this directive.
+ *
+ *     agit-txn-req-end: This directive terminate the session between
+ *         "receive-pack" and Galileo.  An optional checksum and error
+ *         message may send before the flush packet. Example:
+ *
+ *         PKT-LINE("agit-txn-req-end")
+ *         PKT-LINE("checksum e9c022ff72cf02c8afb901e6d308d05e")
+ *         PKT-LINE("error pre-receive hook decliend")
+ *         FLUSH-PKT
+ *
+ * Response from Galileo to "receive-pack":
+ *
+ *     agit-txn-resp-next: Let "receive-pack" continue its process.
+ *         It has one optional parameter (0, or 1).  Default 0,  if
+ *         not parameter is given. The given parameter 1, will
+ *         appoint "receive-pack" as the main instance.  A main
+ *         instance in the "prepare" stage, will execute the
+ *         "execute-commands" hook, and in the "commit" stage, will
+ *         execute the "post-receive" hook.
+ *
+ *         A flush packet will be given after this directive.
+ *
+ *     agit-txn-resp-quit: Let "receive-pack" stop its process, and
+ *         mark all the commands failed.
+ *
+ *         A flush packet will be given after this directive.
+ **/
+#define AGIT_TXN_REQ_PREPARE	"agit-txn-req-prepare"
+#define AGIT_TXN_REQ_COMMIT	"agit-txn-req-commit"
+#define AGIT_TXN_REQ_END	"agit-txn-req-end"
+#define AGIT_TXN_RESP_NEXT	"agit-txn-resp-next"
+#define AGIT_TXN_RESP_QUIT	"agit-txn-resp-quit"
+
 static enum deny_action parse_deny_action(const char *var, const char *value)
 {
 	if (value) {
@@ -1039,9 +1097,15 @@ static int read_proc_receive_report(struct packet_reader *reader,
 				report->new_oid = oiddup(&new_oid);
 			else if (!strcmp(key, "forced-update"))
 				report->forced_update = 1;
-			else if (!strcmp(key, "fall-through"))
+			else if (!strcmp(key, "fall-through")) {
 				/* Fall through, let 'receive-pack' to execute it. */
 				hint->run_proc_receive = 0;
+				if (agit_txn) {
+					hint->error_string = "fall-through mode from proc-receive is incompatible with agit-txn";
+					strbuf_addf(errmsg, "%s\n", hint->error_string);
+					code = -1;
+				}
+			}
 			continue;
 		}
 
@@ -1810,6 +1874,72 @@ static int should_process_cmd(struct command *cmd)
 	return !cmd->error_string && !cmd->skip_update;
 }
 
+static int should_prepare_txn(struct command *commands,
+			      struct packet_reader *reader,
+			      int *run_instance)
+{
+	char *p;
+
+	packet_write_fmt(1, "%s\n", AGIT_TXN_REQ_PREPARE);
+	packet_flush(1);
+
+	for (;;) {
+		packet_reader_read(reader);
+		if (reader->status == PACKET_READ_FLUSH)
+			break;
+
+		if (reader->status != PACKET_READ_NORMAL)
+			die("protocol error: got an unexpected agit txn flag");
+
+		if (reader->pktlen >= strlen(AGIT_TXN_RESP_NEXT) &&
+		    starts_with(reader->line, AGIT_TXN_RESP_NEXT)) {
+			p = strchr(reader->line, ' ');
+			if (p) {
+				*run_instance = atoi(++p);
+			}
+			return 1;
+		}
+
+		if (reader->pktlen >= strlen(AGIT_TXN_RESP_QUIT) &&
+		    starts_with(reader->line, AGIT_TXN_RESP_QUIT))
+			return 0;
+	}
+	return 0;
+}
+
+static int should_commit_txn(struct command *commands,
+			     struct packet_reader *reader,
+			     int *run_instance)
+{
+	char *p;
+
+	packet_write_fmt(1, "%s\n", AGIT_TXN_REQ_COMMIT);
+	packet_flush(1);
+
+	for (;;) {
+		packet_reader_read(reader);
+		if (reader->status == PACKET_READ_FLUSH)
+			break;
+
+		if (reader->status != PACKET_READ_NORMAL)
+			die("protocol error: got an unexpected agit txn flag");
+
+		if (reader->pktlen >= strlen(AGIT_TXN_RESP_NEXT) &&
+		    starts_with(reader->line, AGIT_TXN_RESP_NEXT)) {
+			p = strchr(reader->line, ' ');
+			if (p) {
+				*run_instance = atoi(++p);
+			}
+			return 1;
+		}
+
+		if (reader->pktlen >= strlen(AGIT_TXN_RESP_QUIT) &&
+		    starts_with(reader->line, AGIT_TXN_RESP_QUIT))
+			return 0;
+	}
+	return 0;
+}
+
 static void warn_if_skipped_connectivity_check(struct command *commands,
 					       struct shallow_info *si)
 {
@@ -1900,10 +2030,85 @@ cleanup:
 	strbuf_release(&err);
 }
 
+static void agit_txn_read_checksum(struct strbuf *sum) {
+	struct strbuf checksum_file = STRBUF_INIT;
+	char msg[128];
+	int fd;
+
+	strbuf_addf(&checksum_file, "%s/%s/%s",
+		    the_repository->gitdir,
+		    "info",
+		    "checksum");
+
+	if (access(checksum_file.buf, F_OK) != 0) {
+		struct child_process proc = CHILD_PROCESS_INIT;
+
+		strvec_pushl(&proc.args, "git-checksum", "--init", NULL);
+		proc.in = 0;
+		proc.dir = the_repository->gitdir;
+		proc.stdout_to_stderr = 1;
+		proc.silent_exec_failure = 1;
+
+		if (start_command(&proc))
+			return;
+		finish_command(&proc);
+	}
+
+	if ((fd = open(checksum_file.buf, O_RDONLY)) != -1) {
+		int len;
+
+		if ((len = read(fd, msg, sizeof(msg))) > 0) {
+			char *p;
+			p = strchr(msg, '\n');
+			if (p)
+				*p = '\0';
+			strbuf_addstr(sum, msg);
+		}
+		close(fd);
+	}
+
+	strbuf_release(&checksum_file);
+}
+
+static void agit_txn_end(struct command *commands, char *msg)
+{
+	struct command *cmd;
+	struct strbuf checksum = STRBUF_INIT;
+
+	if (!agit_txn)
+		return;
+
+	packet_write_fmt(1, "%s\n", AGIT_TXN_REQ_END);
+
+	agit_txn_read_checksum(&checksum);
+	if (checksum.len > 0)
+		packet_write_fmt(1, "checksum %s\n", checksum.buf);
+
+	if (msg && strlen(msg) > 0)
+		packet_write_fmt(1, "error %s\n", msg);
+
+	for(cmd = commands; cmd; cmd = cmd->next) {
+		if (cmd->error_string ||
+		    cmd->skip_update ||
+		    cmd->did_not_exist ||
+		    cmd->run_proc_receive)
+			continue;
+
+		packet_write_fmt(1, "%s %s %s\n",
+				 oid_to_hex(&cmd->old_oid),
+				 oid_to_hex(&cmd->new_oid),
+				 cmd->ref_name);
+	}
+
+	packet_flush(1);
+	strbuf_release(&checksum);
+}
+
 static void execute_commands(struct command *commands,
 			     const char *unpacker_error,
 			     struct shallow_info *si,
-			     const struct string_list *push_options)
+			     const struct string_list *push_options,
+			     struct packet_reader *reader)
 {
 	struct check_connected_options opt = CHECK_CONNECTED_INIT;
 	struct command *cmd;
@@ -1915,6 +2120,7 @@ static void execute_commands(struct command *commands,
 	if (unpacker_error) {
 		for (cmd = commands; cmd; cmd = cmd->next)
 			cmd->error_string = "unpacker error";
+		agit_txn_end(commands, "unpacker error");
 		return;
 	}
 
@@ -1961,9 +2167,21 @@ static void execute_commands(struct command *commands,
 			if (!cmd->error_string)
 				cmd->error_string = "pre-receive hook declined";
 		}
+		agit_txn_end(commands, "pre-receive hook decliend");
 		return;
 	}
 
+	/* agit-txn-prepare: run proc-receive hook */
+	if (agit_txn)
+		if (!should_prepare_txn(commands, reader, &agit_main_instance)) {
+			for (cmd = commands; cmd; cmd = cmd->next) {
+				if (!cmd->error_string)
+					cmd->error_string = "transaction prepared failed";
+			}
+			agit_txn_end(commands, "transaction prepared failed");
+			return;
+		}
+
 	/*
 	 * If there is no command ready to run, should return directly to destroy
 	 * temporary data in the quarantine area.
@@ -1982,6 +2200,7 @@ static void execute_commands(struct command *commands,
 			if (!cmd->error_string)
 				cmd->error_string = "unable to migrate objects to permanent storage";
 		}
+		agit_txn_end(commands, "objects migrate failed");
 		return;
 	}
 	tmp_objdir = NULL;
@@ -1992,12 +2211,37 @@ static void execute_commands(struct command *commands,
 	head_name = head_name_to_free = resolve_refdup("HEAD", 0, NULL, NULL);
 
 	if (run_proc_receive &&
-	    run_proc_receive_hook(commands, push_options))
+	    (!agit_txn || agit_main_instance) &&
+	    run_proc_receive_hook(commands, push_options)) {
+		/*
+		 * If agit_txn is enabled, only one instance will execute proc_receive_hook.
+		 * Other instances will report ok for all references which not match the result
+		 * returned from this master instance. So quit.
+		 */
+		if (agit_txn) {
+			agit_txn_end(commands, "proc-receive hook failed");
+			return;
+		}
+
 		for (cmd = commands; cmd; cmd = cmd->next)
 			if (!cmd->error_string &&
 			    !(cmd->run_proc_receive & RUN_PROC_RECEIVE_RETURNED) &&
 			    (cmd->run_proc_receive || use_atomic))
 				cmd->error_string = "fail to run proc-receive hook";
+	}
+
+	/* agit-txn-commit: run internal execute_commands_*() function */
+	if (agit_txn) {
+		agit_main_instance = 0;
+		if (!should_commit_txn(commands, reader, &agit_main_instance)) {
+			for (cmd = commands; cmd; cmd = cmd->next) {
+				if (!cmd->error_string)
+					cmd->error_string = "transaction commit failed";
+			}
+			agit_txn_end(commands, "transaction commit failed");
+			return;
+		}
+	}
 
 	if (use_atomic)
 		execute_commands_atomic(commands, si);
@@ -2006,6 +2250,9 @@ static void execute_commands(struct command *commands,
 
 	if (shallow_update)
 		warn_if_skipped_connectivity_check(commands, si);
+
+	if (agit_txn)
+		agit_txn_end(commands, NULL);
 }
 
 static struct command **queue_command(struct command **tail,
@@ -2478,6 +2725,7 @@ int cmd_receive_pack(int argc, const char **argv, const char *prefix)
 		OPT_HIDDEN_BOOL(0, "http-backend-info-refs", &advertise_refs, NULL),
 		OPT_ALIAS(0, "advertise-refs", "http-backend-info-refs"),
 		OPT_HIDDEN_BOOL(0, "reject-thin-pack-for-testing", &reject_thin, NULL),
+		OPT_HIDDEN_BOOL(0, "agit-txn", &agit_txn, NULL),
 		OPT_END()
 	};
 
@@ -2559,7 +2807,7 @@ int cmd_receive_pack(int argc, const char **argv, const char *prefix)
 		}
 		use_keepalive = KEEPALIVE_ALWAYS;
 		execute_commands(commands, unpack_status, &si,
-				 &push_options);
+				 &push_options, &reader);
 		if (pack_lockfile)
 			unlink_or_warn(pack_lockfile);
 		sigchain_push(SIGPIPE, SIG_IGN);
@@ -2568,9 +2816,11 @@ int cmd_receive_pack(int argc, const char **argv, const char *prefix)
 		else if (report_status)
 			report(commands, unpack_status);
 		sigchain_pop(SIGPIPE);
-		run_receive_hook(commands, "post-receive", 1,
-				 &push_options);
-		run_update_post_hook(commands);
+		if (!agit_txn || agit_main_instance) {
+			run_receive_hook(commands, "post-receive", 1,
+					 &push_options);
+			run_update_post_hook(commands);
+		}
 		string_list_clear(&push_options, 0);
 		if (auto_gc) {
 			struct child_process proc = CHILD_PROCESS_INIT;
diff --git a/t/t0932-agit-receive-txn.sh b/t/t0932-agit-receive-txn.sh
new file mode 100755
index 0000000000..82a9238335
--- /dev/null
+++ b/t/t0932-agit-receive-txn.sh
@@ -0,0 +1,246 @@
+#!/bin/bash
+
+test_description='git receive-pack with alternate ref filtering'
+
+GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME=main
+export GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME
+
+. ./test-lib.sh
+
+make_stable_pktline_output () {
+	perl -p -e '
+		s#([0-9a-f]{4}checksum) [0-9a-f]*#\1 <checksum>#;
+		s#( refs/heads/main).*$#\1#;
+	'
+}
+
+start_receive_pack() {
+	git-receive-pack "$@" repo
+}
+
+start_proxy_client() {
+	if test "$GIT_TEST_DEFAULT_HASH" = sha256
+	then
+		printf "00da$ZERO_OID $txn_tip refs/heads/test01\0report-status side-band-64k object-format=sha256 agent=git/2.24.x\n"
+	else
+		printf "0095$ZERO_OID $txn_tip refs/heads/test01\0report-status side-band-64k agent=git/2.24.x\n"
+	fi
+	printf "0000"
+	printf "" | git pack-objects --stdout
+	msg=
+	while read input
+	do
+		if test -z "$input"
+		then
+			break
+		fi
+
+		printf "$input\n" >&7
+
+		if echo "$input" | grep -q "agit-txn-req" && test $# -gt 0
+		then
+			case $1 in
+			next0 | next)
+				printf "0019agit-txn-resp-next 0\n"
+				;;
+			next1)
+				printf "0019agit-txn-resp-next 1\n"
+				;;
+			quit)
+				printf "0017agit-txn-resp-quit\n"
+				;;
+			flush)
+				printf "0000"
+				;;
+			abnormal)
+				printf "EOF\n"
+				;;
+			esac
+			shift
+		fi
+	done
+}
+
+if test "$GIT_TEST_DEFAULT_HASH" = sha256
+then
+	pktline_len_branch_main=0055
+	pktline_len_tag_base=0054
+	pktline_len_update_branch_test01=0098
+else
+	pktline_len_branch_main=003d
+	pktline_len_tag_base=003c
+	pktline_len_update_branch_test01=0068
+fi
+
+test_expect_success PIPE 'setup' '
+	test_commit base &&
+	git clone -s --bare . repo &&
+	txn_tip=$(git rev-parse HEAD) &&
+	advertise_refs_first_line=$(git-receive-pack --advertise-refs repo|head -n 1) &&
+	suffix=${advertise_refs_first_line#????} &&
+	pktline_len_branch_main=${advertise_refs_first_line%$suffix}
+'
+
+test_expect_success PIPE 'standard git-receive-pack process' '
+	mkfifo pipe &&
+	start_receive_pack <pipe | \
+		start_proxy_client >pipe 7>out &&
+	make_stable_pktline_output <out >actual &&
+	cat >expect<<-EOF &&
+	${pktline_len_branch_main}${txn_tip} refs/heads/main
+	${pktline_len_tag_base}${txn_tip} refs/tags/base
+	00000030$(printf "\1")000eunpack ok
+	0019ok refs/heads/test01
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success PIPE 'cleanup' '
+	rm -f pipe &&
+	git -C repo update-ref -d refs/heads/test01
+'
+
+test_expect_success PIPE 'create 32-byte checksum file (in case no git-checksum installed)' '
+	cat >repo/info/checksum <<-EOF
+	12345678901234567890123456789012
+	EOF
+'
+
+test_expect_success PIPE 'receive pack with txn success' '
+	rm -f pipe &&
+	mkfifo pipe &&
+	start_receive_pack --agit-txn <pipe | \
+		start_proxy_client next next >pipe 7>out &&
+	make_stable_pktline_output <out >actual &&
+	cat >expect<<-EOF &&
+	${pktline_len_branch_main}${txn_tip} refs/heads/main
+	${pktline_len_tag_base}${txn_tip} refs/tags/base
+	00000019agit-txn-req-prepare
+	00000018agit-txn-req-commit
+	00000015agit-txn-req-end
+	002echecksum <checksum>
+	${pktline_len_update_branch_test01}$ZERO_OID $txn_tip refs/heads/test01
+	00000030$(printf "\1")000eunpack ok
+	0019ok refs/heads/test01
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success PIPE 'cleanup' '
+	rm -f pipe &&
+	git -C repo update-ref -d refs/heads/test01
+'
+
+test_expect_success PIPE 'txn: prepare failed' '
+	mkfifo pipe &&
+	start_receive_pack --agit-txn <pipe | \
+		start_proxy_client quit >pipe 7>out &&
+	make_stable_pktline_output <out >actual &&
+	cat >expect <<-EOF &&
+	${pktline_len_branch_main}${txn_tip} refs/heads/main
+	${pktline_len_tag_base}${txn_tip} refs/tags/base
+	00000019agit-txn-req-prepare
+	00000015agit-txn-req-end
+	002echecksum <checksum>
+	0026error transaction prepared failed
+	0000004c$(printf "\1")000eunpack ok
+	0035ng refs/heads/test01 transaction prepared failed
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success PIPE 'cleanup' '
+	rm -f pipe
+'
+
+test_expect_success PIPE 'txn: commit failed' '
+	mkfifo pipe &&
+	start_receive_pack --agit-txn <pipe | \
+		start_proxy_client next1 quit >pipe 7>out &&
+	make_stable_pktline_output <out >actual &&
+	cat >expect <<-EOF &&
+	${pktline_len_branch_main}${txn_tip} refs/heads/main
+	${pktline_len_tag_base}${txn_tip} refs/tags/base
+	00000019agit-txn-req-prepare
+	00000018agit-txn-req-commit
+	00000015agit-txn-req-end
+	002echecksum <checksum>
+	0024error transaction commit failed
+	0000004a$(printf "\1")000eunpack ok
+	0033ng refs/heads/test01 transaction commit failed
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success PIPE 'cleanup' '
+	rm -f pipe
+'
+
+test_expect_success PIPE 'setup pre-receive hook' '
+	cat >./repo/hooks/pre-receive <<-\EOF &&
+	#!/bin/bash
+	exit 1
+	EOF
+	chmod 755 ./repo/hooks/pre-receive
+'
+
+test_expect_success PIPE 'receive pack with txn but pre hook failed' '
+	mkfifo pipe &&
+	start_receive_pack --agit-txn <pipe | \
+		start_proxy_client >pipe 7>out &&
+	make_stable_pktline_output <out >actual &&
+	cat >expect <<-EOF &&
+	${pktline_len_branch_main}${txn_tip} refs/heads/main
+	${pktline_len_tag_base}${txn_tip} refs/tags/base
+	00000015agit-txn-req-end
+	002echecksum <checksum>
+	0024error pre-receive hook decliend
+	0000004a$(printf "\1")000eunpack ok
+	0033ng refs/heads/test01 pre-receive hook declined
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success PIPE 'cleanup' '
+	rm -f pipe &&
+	rm -f ./repo/hooks/pre-receive
+'
+
+test_expect_success PIPE 'receive pack agit txn receive abnormal pktline' '
+	mkfifo pipe &&
+	printf "" > actual &&
+	start_receive_pack --agit-txn <pipe | \
+		start_proxy_client abnormal >pipe 7>out &&
+	make_stable_pktline_output <out >actual &&
+	cat >expect <<-EOF &&
+	${pktline_len_branch_main}${txn_tip} refs/heads/main
+	${pktline_len_tag_base}${txn_tip} refs/tags/base
+	00000019agit-txn-req-prepare
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success PIPE 'cleanup' '
+	rm -f pipe
+'
+
+test_expect_success PIPE 'receive pack agit txn receive flush pktline' '
+	mkfifo pipe &&
+	printf "" > actual &&
+	start_receive_pack --agit-txn <pipe | \
+		start_proxy_client flush >pipe 7>out &&
+	make_stable_pktline_output <out >actual &&
+	cat >expect <<-EOF &&
+	${pktline_len_branch_main}${txn_tip} refs/heads/main
+	${pktline_len_tag_base}${txn_tip} refs/tags/base
+	00000019agit-txn-req-prepare
+	00000015agit-txn-req-end
+	002echecksum <checksum>
+	0026error transaction prepared failed
+	0000004c$(printf "\1")000eunpack ok
+	0035ng refs/heads/test01 transaction prepared failed
+	EOF
+	test_cmp expect actual
+'
+
+test_done
-- 
patchwork
