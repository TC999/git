From 5724dfffd867e38b10a09edac4469962104bef67 Mon Sep 17 00:00:00 2001
From: Han Xin <hanxin.hx@alibaba-inc.com>
Date: Thu, 6 Jan 2022 17:56:36 +0800
Subject: [PATCH 78/84] direct-to-packed-refs: new extension for refs API

Add new interfaces to refs API, so we can update references directly
into packed ref-store instead of files refs-store to increase
performance.

Han Xin's original implementation is removed due to incompatible with
the reference-transaction hook.

EDIT:

  * [2022/08/25] Refactor: add two new interfaces:
    "transaction_prepare_extended" and "transaction_finish_extended"
    to replace "direct_to_packed_refs".

  * [2022/08/23]: Removed obsolete implementation from Chi Tian
    (Han Xin). See the patch below:

    diff --git a/refs/files-backend.c b/refs/files-backend.c
    index 1db046559a..57ead5083f 100644
    --- a/refs/files-backend.c
    +++ b/refs/files-backend.c
    @@ -1265,128 +1265,6 @@ static int files_pack_refs(struct ref_store *ref_store, unsigned int flags)
     	return 0;
     }

    -static int ref_contains(struct string_list *refnames,
    -			const char *refname)
    -{
    -	size_t i, n = refnames->nr;
    -
    -	for (i = 0; i < n; i++) {
    -		if (!strcmp(refname, refnames->items[i].string))
    -			return 1;
    -	}
    -	return 0;
    -}
    -
    -static int files_direct_to_packed_refs(struct ref_store *ref_store,
    -				       struct ref_transaction *transaction,
    -				       struct strbuf *err)
    -{
    -	struct files_ref_store *refs = files_downcast(
    -		ref_store, REF_STORE_WRITE | REF_STORE_ODB, "direct_to_packed_refs");
    -	struct ref_iterator *iter;
    -	size_t i;
    -	int ok, ret = 0;
    -	struct string_list affected_refnames = STRING_LIST_INIT_NODUP;
    -	struct ref_to_prune *refs_to_prune = NULL;
    -	struct ref_transaction *packed_transaction = NULL;
    -
    -	assert(err);
    -
    -	if (transaction->state != REF_TRANSACTION_OPEN)
    -		BUG("commit called for transaction that is not open");
    -
    -	/* Fail if a refname appears more than once in the transaction: */
    -	for (i = 0; i < transaction->nr; i++)
    -		string_list_append(&affected_refnames,
    -				   transaction->updates[i]->refname);
    -	string_list_sort(&affected_refnames);
    -	if (ref_update_reject_duplicates(&affected_refnames, err)) {
    -		ret = TRANSACTION_GENERIC_ERROR;
    -		string_list_clear(&affected_refnames, 0);
    -		goto cleanup;
    -	}
    -
    -	packed_transaction =
    -		ref_store_transaction_begin(refs->packed_ref_store, err);
    -	if (!packed_transaction) {
    -		ret = TRANSACTION_GENERIC_ERROR;
    -		string_list_clear(&affected_refnames, 0);
    -		return ret;
    -	}
    -
    -	packed_refs_lock(refs->packed_ref_store, LOCK_DIE_ON_ERROR, err);
    -
    -	for (i = 0; i < transaction->nr; i++) {
    -		struct ref_update *update = transaction->updates[i];
    -
    -		if (refs_verify_refname_available(&refs->base, update->refname,
    -						  &affected_refnames, NULL,
    -						  err)) {
    -			ret = TRANSACTION_NAME_CONFLICT;
    -			packed_refs_unlock(refs->packed_ref_store);
    -			goto cleanup;
    -		}
    -
    -		/*
    -		 * Add a reference creation for this reference to the
    -		 * packed-refs transaction:
    -		 */
    -		ref_transaction_add_update(packed_transaction, update->refname,
    -					   update->flags & ~REF_HAVE_OLD,
    -					   &update->new_oid, &update->old_oid,
    -					   NULL);
    -	}
    -
    -	iter = cache_ref_iterator_begin(get_loose_ref_cache(refs), NULL,
    -					the_repository, 0);
    -	while ((ok = ref_iterator_advance(iter)) == ITER_OK) {
    -		struct ref_to_prune *n;
    -
    -		/* duplicate ref from loose items */
    -		if (!ref_contains(&affected_refnames, iter->refname)) {
    -			/*
    -			 * If the loose reference can be packed, add an entry
    -			 * in the packed ref cache. If the reference should be
    -			 * pruned, also add it to refs_to_prune.
    -			 */
    -			if (!should_pack_ref(iter->refname, iter->oid,
    -					     iter->flags, PACK_REFS_ALL))
    -				continue;
    -
    -			/*
    -			 * Add a reference creation for this reference to the
    -			 * packed-refs transaction:
    -			 */
    -			if (ref_transaction_update(
    -				    packed_transaction, iter->refname,
    -				    iter->oid, NULL, REF_NO_DEREF, NULL, err))
    -				die("failure preparing to create packed reference %s: %s",
    -				    iter->refname, err->buf);
    -		}
    -
    -		/* Schedule the loose reference for pruning if requested. */
    -		FLEX_ALLOC_STR(n, name, iter->refname);
    -		oidcpy(&n->oid, iter->oid);
    -		n->next = refs_to_prune;
    -		refs_to_prune = n;
    -	}
    -	if (ok != ITER_DONE)
    -		die("error while iterating over references");
    -
    -	if (ref_transaction_commit(packed_transaction, err))
    -		die("unable to write new packed-refs: %s", err->buf);
    -
    -	packed_refs_unlock(refs->packed_ref_store);
    -
    -	prune_refs(refs, &refs_to_prune);
    -cleanup:
    -	string_list_clear(&affected_refnames, 0);
    -	if (packed_transaction)
    -		ref_transaction_free(packed_transaction);
    -	transaction->state = REF_TRANSACTION_CLOSED;
    -	return ret;
    -}
    -
     static int files_delete_refs(struct ref_store *ref_store, const char *msg,
     			     struct string_list *refnames, unsigned int flags)
     {
    @@ -3363,7 +3241,7 @@ struct ref_storage_be refs_be_files = {
     	.delete_refs = files_delete_refs,
     	.rename_ref = files_rename_ref,
     	.copy_ref = files_copy_ref,
    -	.direct_to_packed_refs = files_direct_to_packed_refs,
    +	.direct_to_packed_refs = NULL,

     	.iterator_begin = files_ref_iterator_begin,
     	.read_raw_ref = files_read_raw_ref,

Signed-off-by: Han Xin <hanxin.hx@alibaba-inc.com>
Signed-off-by: Jiang Xin <zhiyou.jx@alibaba-inc.com>
---
 refs.c                | 50 +++++++++++++++++++++----
 refs.h                |  6 +++
 refs/debug.c          | 42 ++++++++++++++++-----
 refs/files-backend.c  | 87 ++++++++++++++++++++++++++++++++++++++++---
 refs/packed-backend.c | 30 ++++++++++++---
 refs/refs-internal.h  | 12 ++++++
 6 files changed, 198 insertions(+), 29 deletions(-)

diff --git a/refs.c b/refs.c
index 517bac986e..88b0a69195 100644
--- a/refs.c
+++ b/refs.c
@@ -2190,8 +2190,17 @@ static int run_transaction_hook(struct ref_transaction *transaction,
 	return ret;
 }
 
-int ref_transaction_prepare(struct ref_transaction *transaction,
-			    struct strbuf *err)
+/*
+ * The extended version of ref_transaction_prepare will prepare transaction
+ * for the main ref-store or for the packed ref-store * according to the
+ * argument "direct_to_packed_refs".
+ *
+ * We should use ref_transaction_prepare* and ref_transaction_commit* in
+ * pairs.
+ */
+int ref_transaction_prepare_extended(struct ref_transaction *transaction,
+				     struct strbuf *err,
+				     int direct_to_packed_refs)
 {
 	struct ref_store *refs = transaction->ref_store;
 	int ret;
@@ -2217,7 +2226,8 @@ int ref_transaction_prepare(struct ref_transaction *transaction,
 		return -1;
 	}
 
-	ret = refs->be->transaction_prepare(refs, transaction, err);
+	ret = refs->be->transaction_prepare_extended(refs, transaction, err,
+						     direct_to_packed_refs);
 	if (ret)
 		return ret;
 
@@ -2230,6 +2240,13 @@ int ref_transaction_prepare(struct ref_transaction *transaction,
 	return 0;
 }
 
+int ref_transaction_prepare(struct ref_transaction *transaction,
+			    struct strbuf *err)
+{
+
+	return ref_transaction_prepare_extended(transaction, err, 0);
+}
+
 int ref_transaction_abort(struct ref_transaction *transaction,
 			  struct strbuf *err)
 {
@@ -2257,8 +2274,17 @@ int ref_transaction_abort(struct ref_transaction *transaction,
 	return ret;
 }
 
-int ref_transaction_commit(struct ref_transaction *transaction,
-			   struct strbuf *err)
+/*
+ * The extended version of ref_transaction_commit can write changes
+ * of references directly to "packed-refs" if the given argument
+ * "direct_to_packed_refs" is set to 1.
+ *
+ * We should use ref_transaction_prepare* and ref_transaction_commit* in
+ * pairs.
+ */
+int ref_transaction_commit_extended(struct ref_transaction *transaction,
+				    struct strbuf *err,
+				    int direct_to_packed_refs)
 {
 	struct ref_store *refs = transaction->ref_store;
 	int ret;
@@ -2266,7 +2292,8 @@ int ref_transaction_commit(struct ref_transaction *transaction,
 	switch (transaction->state) {
 	case REF_TRANSACTION_OPEN:
 		/* Need to prepare first. */
-		ret = ref_transaction_prepare(transaction, err);
+		ret = ref_transaction_prepare_extended(
+				transaction, err, direct_to_packed_refs);
 		if (ret)
 			return ret;
 		break;
@@ -2281,12 +2308,21 @@ int ref_transaction_commit(struct ref_transaction *transaction,
 		break;
 	}
 
-	ret = refs->be->transaction_finish(refs, transaction, err);
+	ret = refs->be->transaction_finish_extended(refs,
+						    transaction,
+						    err,
+						    direct_to_packed_refs);
 	if (!ret)
 		run_transaction_hook(transaction, "committed");
 	return ret;
 }
 
+int ref_transaction_commit(struct ref_transaction *transaction,
+			   struct strbuf *err)
+{
+	return ref_transaction_commit_extended(transaction, err, 0);
+}
+
 int refs_verify_refname_available(struct ref_store *refs,
 				  const char *refname,
 				  const struct string_list *extras,
diff --git a/refs.h b/refs.h
index 85832c4863..2b73736cc4 100644
--- a/refs.h
+++ b/refs.h
@@ -757,6 +757,9 @@ int ref_transaction_verify(struct ref_transaction *transaction,
  */
 int ref_transaction_prepare(struct ref_transaction *transaction,
 			    struct strbuf *err);
+int ref_transaction_prepare_extended(struct ref_transaction *transaction,
+				     struct strbuf *err,
+				     int direct_to_packed_refs);
 
 /*
  * Commit all of the changes that have been queued in transaction, as
@@ -767,6 +770,9 @@ int ref_transaction_prepare(struct ref_transaction *transaction,
  */
 int ref_transaction_commit(struct ref_transaction *transaction,
 			   struct strbuf *err);
+int ref_transaction_commit_extended(struct ref_transaction *transaction,
+				    struct strbuf *err,
+				    int direct_to_packed_refs);
 
 /*
  * Abort `transaction`, which has been begun and possibly prepared,
diff --git a/refs/debug.c b/refs/debug.c
index 1e60507249..c2deedd398 100644
--- a/refs/debug.c
+++ b/refs/debug.c
@@ -39,20 +39,30 @@ static int debug_init_db(struct ref_store *refs, struct strbuf *err)
 	return res;
 }
 
-static int debug_transaction_prepare(struct ref_store *refs,
-				     struct ref_transaction *transaction,
-				     struct strbuf *err)
+static int debug_transaction_prepare_extended(struct ref_store *refs,
+					      struct ref_transaction *transaction,
+					      struct strbuf *err,
+					      int direct_to_packed_refs)
 {
 	struct debug_ref_store *drefs = (struct debug_ref_store *)refs;
 	int res;
 	transaction->ref_store = drefs->refs;
-	res = drefs->refs->be->transaction_prepare(drefs->refs, transaction,
-						   err);
+	res = drefs->refs->be->transaction_prepare_extended(drefs->refs,
+							    transaction,
+							    err,
+							    direct_to_packed_refs);
 	trace_printf_key(&trace_refs, "transaction_prepare: %d \"%s\"\n", res,
 			 err->buf);
 	return res;
 }
 
+static int debug_transaction_prepare(struct ref_store *refs,
+				     struct ref_transaction *transaction,
+				     struct strbuf *err)
+{
+	return debug_transaction_prepare_extended(refs, transaction, err, 0);
+}
+
 static void print_update(int i, const char *refname,
 			 const struct object_id *old_oid,
 			 const struct object_id *new_oid, unsigned int flags,
@@ -84,20 +94,30 @@ static void print_transaction(struct ref_transaction *transaction)
 	trace_printf_key(&trace_refs, "}\n");
 }
 
-static int debug_transaction_finish(struct ref_store *refs,
-				    struct ref_transaction *transaction,
-				    struct strbuf *err)
+static int debug_transaction_finish_extended(struct ref_store *refs,
+					     struct ref_transaction *transaction,
+					     struct strbuf *err,
+					     int direct_to_packed_refs)
 {
 	struct debug_ref_store *drefs = (struct debug_ref_store *)refs;
 	int res;
 	transaction->ref_store = drefs->refs;
-	res = drefs->refs->be->transaction_finish(drefs->refs, transaction,
-						  err);
+	res = drefs->refs->be->transaction_finish_extended(drefs->refs,
+							   transaction,
+							   err,
+							   direct_to_packed_refs);
 	print_transaction(transaction);
 	trace_printf_key(&trace_refs, "finish: %d\n", res);
 	return res;
 }
 
+static int debug_transaction_finish(struct ref_store *refs,
+				    struct ref_transaction *transaction,
+				    struct strbuf *err)
+{
+	return debug_transaction_finish_extended(refs, transaction, err, 0);
+}
+
 static int debug_transaction_abort(struct ref_store *refs,
 				   struct ref_transaction *transaction,
 				   struct strbuf *err)
@@ -449,7 +469,9 @@ struct ref_storage_be refs_be_debug = {
 	 * Test the output with "GIT_TRACE_REFS=1".
 	 */
 	.transaction_prepare = debug_transaction_prepare,
+	.transaction_prepare_extended = debug_transaction_prepare_extended,
 	.transaction_finish = debug_transaction_finish,
+	.transaction_finish_extended = debug_transaction_finish_extended,
 	.transaction_abort = debug_transaction_abort,
 	.initial_transaction_commit = debug_initial_transaction_commit,
 
diff --git a/refs/files-backend.c b/refs/files-backend.c
index 8f3deddc71..c320a4a19c 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
@@ -2608,9 +2608,10 @@ static void files_transaction_cleanup(struct files_ref_store *refs,
 	transaction->state = REF_TRANSACTION_CLOSED;
 }
 
-static int files_transaction_prepare(struct ref_store *ref_store,
-				     struct ref_transaction *transaction,
-				     struct strbuf *err)
+static int files_transaction_prepare_extended(struct ref_store *ref_store,
+					      struct ref_transaction *transaction,
+					      struct strbuf *err,
+					      int direct_to_packed_refs)
 {
 	struct files_ref_store *refs =
 		files_downcast(ref_store, REF_STORE_WRITE,
@@ -2784,9 +2785,74 @@ cleanup:
 	return ret;
 }
 
-static int files_transaction_finish(struct ref_store *ref_store,
-				    struct ref_transaction *transaction,
-				    struct strbuf *err)
+static int files_transaction_prepare(struct ref_store *ref_store,
+				     struct ref_transaction *transaction,
+				     struct strbuf *err)
+{
+	return files_transaction_prepare_extended(ref_store, transaction, err, 0);
+}
+
+/*
+ * We have already prepared the transaction with the following changes:
+ *
+ *   1. Packed ref-store is prepared if necessary with locked packed-refs,
+ *      and packed-refs.new is written by removing delete-refs.
+ *
+ *   2. Each loose references is locked, and the old-oid of each update
+ *      entry of the transaction is set properly according to the
+ *      locked loose reference.
+ *
+ *   3. Each symref (not marked as REF_NO_DEREF) will be resolved and
+ *      add a new update entry for the real reference it points to.
+ *
+ * Each update entry may has the following flags, some of them are maked
+ * duing lock_ref_for_update():
+ *
+ *   1. REF_DELETING: For references should be deleted. These update
+ *      entries should have marked with REF_HAVE_NEW and the new_oid is
+ *      null_oid().
+ *
+ *   2. REF_NEEDS_COMMIT: For references should be created or updated
+ *      with new oid.  These update entries should not mark with
+ *      REF_DELETING and REF_LOG_ONLY, and the new-oid should be
+ *      different with the oid of the lockfile. We will write the new-oid
+ *      to the lockfile, and the lockfile is prepared for committing to
+ *      the loose reference file.
+ *
+ *   3. REF_LOG_ONLY: Only update reflog, but should not update/delete
+ *      the loose reference file.
+ *
+ *   4. REF_IS_PRUNING: The event is triggered by git-pack-refs, and
+ *      the loose reference has already been packed into the packed-refs
+ *      file. We should delete the loose reference file, but keep the
+ *      reflog file as is.
+ *
+ *   5. REF_UPDATE_VIA_HEAD: The reference is pointed and splitted from
+ *      HEAD, mark with this flag to prevent duplicate splitting.
+ *
+ *   6. REF_HAVE_NEW: Have new-oid, and given by ref_transaction_add_update().
+ *
+ *   7. REF_HAVE_OLD: Have old-oid, and given by ref_transaction_add_update().
+ *
+ * Each update entry may have a type that denotes the kind of the reference.
+ *
+ *   1. REF_ISSYMREF: reference is a symref.
+ *   2. REF_ISPACKED: reference is defined in the packed-ref file.
+ *   3. REF_ISBROKEN: bad loose reference file.
+ *
+ * In the prepare stage, we did:
+ *
+ *   * Prepare the new transaction for packed-ref-store with all update
+ *     entries including both deleting refs and changed refs.
+ *
+ * In the finish sage, we should:
+ *
+ *   * Do not commit but delete refereces which marked as REF_NEEDS_COMMIT.
+ */
+static int files_transaction_finish_extended(struct ref_store *ref_store,
+					     struct ref_transaction *transaction,
+					     struct strbuf *err,
+					     int direct_to_packed_refs)
 {
 	struct files_ref_store *refs =
 		files_downcast(ref_store, 0, "ref_transaction_finish");
@@ -2930,6 +2996,13 @@ cleanup:
 	return ret;
 }
 
+static int files_transaction_finish(struct ref_store *ref_store,
+				    struct ref_transaction *transaction,
+				    struct strbuf *err)
+{
+	return files_transaction_finish_extended(ref_store, transaction, err, 0);
+}
+
 static int files_transaction_abort(struct ref_store *ref_store,
 				   struct ref_transaction *transaction,
 				   struct strbuf *err)
@@ -3232,7 +3305,9 @@ struct ref_storage_be refs_be_files = {
 	.init = files_ref_store_create,
 	.init_db = files_init_db,
 	.transaction_prepare = files_transaction_prepare,
+	.transaction_prepare_extended = files_transaction_prepare_extended,
 	.transaction_finish = files_transaction_finish,
+	.transaction_finish_extended = files_transaction_finish_extended,
 	.transaction_abort = files_transaction_abort,
 	.initial_transaction_commit = files_initial_transaction_commit,
 
diff --git a/refs/packed-backend.c b/refs/packed-backend.c
index fdb7a0a52c..ccea6259df 100644
--- a/refs/packed-backend.c
+++ b/refs/packed-backend.c
@@ -1411,9 +1411,10 @@ static void packed_transaction_cleanup(struct packed_ref_store *refs,
 	transaction->state = REF_TRANSACTION_CLOSED;
 }
 
-static int packed_transaction_prepare(struct ref_store *ref_store,
-				      struct ref_transaction *transaction,
-				      struct strbuf *err)
+static int packed_transaction_prepare_extended(struct ref_store *ref_store,
+					       struct ref_transaction *transaction,
+					       struct strbuf *err,
+					       int direct_to_packed_refs)
 {
 	struct packed_ref_store *refs = packed_downcast(
 			ref_store,
@@ -1471,6 +1472,13 @@ failure:
 	return ret;
 }
 
+static int packed_transaction_prepare(struct ref_store *ref_store,
+				      struct ref_transaction *transaction,
+				      struct strbuf *err)
+{
+	return packed_transaction_prepare_extended(ref_store, transaction, err, 0);
+}
+
 static int packed_transaction_abort(struct ref_store *ref_store,
 				    struct ref_transaction *transaction,
 				    struct strbuf *err)
@@ -1484,9 +1492,10 @@ static int packed_transaction_abort(struct ref_store *ref_store,
 	return 0;
 }
 
-static int packed_transaction_finish(struct ref_store *ref_store,
-				     struct ref_transaction *transaction,
-				     struct strbuf *err)
+static int packed_transaction_finish_extended(struct ref_store *ref_store,
+					      struct ref_transaction *transaction,
+					      struct strbuf *err,
+					      int direct_to_packed_refs)
 {
 	struct packed_ref_store *refs = packed_downcast(
 			ref_store,
@@ -1512,6 +1521,13 @@ cleanup:
 	return ret;
 }
 
+static int packed_transaction_finish(struct ref_store *ref_store,
+				     struct ref_transaction *transaction,
+				     struct strbuf *err)
+{
+	return packed_transaction_finish_extended(ref_store, transaction, err, 0);
+}
+
 static int packed_initial_transaction_commit(struct ref_store *ref_store,
 					    struct ref_transaction *transaction,
 					    struct strbuf *err)
@@ -1540,7 +1556,9 @@ struct ref_storage_be refs_be_packed = {
 	.init = packed_ref_store_create,
 	.init_db = packed_init_db,
 	.transaction_prepare = packed_transaction_prepare,
+	.transaction_prepare_extended = packed_transaction_prepare_extended,
 	.transaction_finish = packed_transaction_finish,
+	.transaction_finish_extended = packed_transaction_finish_extended,
 	.transaction_abort = packed_transaction_abort,
 	.initial_transaction_commit = packed_initial_transaction_commit,
 
diff --git a/refs/refs-internal.h b/refs/refs-internal.h
index 1f86887155..4d23bcae42 100644
--- a/refs/refs-internal.h
+++ b/refs/refs-internal.h
@@ -557,10 +557,20 @@ typedef int ref_transaction_prepare_fn(struct ref_store *refs,
 				       struct ref_transaction *transaction,
 				       struct strbuf *err);
 
+typedef int ref_transaction_prepare_extended_fn(struct ref_store *refs,
+						struct ref_transaction *transaction,
+						struct strbuf *err,
+						int direct_to_packed_refs);
+
 typedef int ref_transaction_finish_fn(struct ref_store *refs,
 				      struct ref_transaction *transaction,
 				      struct strbuf *err);
 
+typedef int ref_transaction_finish_extended_fn(struct ref_store *refs,
+					       struct ref_transaction *transaction,
+					       struct strbuf *err,
+					       int direct_to_packed_refs);
+
 typedef int ref_transaction_abort_fn(struct ref_store *refs,
 				     struct ref_transaction *transaction,
 				     struct strbuf *err);
@@ -691,7 +701,9 @@ struct ref_storage_be {
 	ref_init_db_fn *init_db;
 
 	ref_transaction_prepare_fn *transaction_prepare;
+	ref_transaction_prepare_extended_fn *transaction_prepare_extended;
 	ref_transaction_finish_fn *transaction_finish;
+	ref_transaction_finish_extended_fn *transaction_finish_extended;
 	ref_transaction_abort_fn *transaction_abort;
 	ref_transaction_commit_fn *initial_transaction_commit;
 
-- 
patchwork
