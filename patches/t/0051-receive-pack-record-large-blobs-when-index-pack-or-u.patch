From 4421c39ac6cd745377c5e2a32f02be68a9db9e74 Mon Sep 17 00:00:00 2001
From: Han Xin <hanxin.hx@alibaba-inc.com>
Date: Mon, 6 Dec 2021 17:37:12 +0800
Subject: [PATCH 51/52] receive-pack: record large blobs when index-pack or
 unpack-objects

Large blobs which larger than "core.bigFileThreshold" will be writen
into "info/large-blobs" with oid and size.

Signed-off-by: Han Xin <hanxin.hx@alibaba-inc.com>
---
 Documentation/config/receive.txt |   5 ++
 Makefile                         |   1 +
 builtin/index-pack.c             |  31 ++++++++-
 builtin/receive-pack.c           |  10 +++
 builtin/unpack-objects.c         |  11 ++-
 cache.h                          |   1 +
 environment.c                    |   1 +
 info-files.c                     |  22 ++++++
 info-files.h                     |   8 +++
 object-file.c                    |  20 +++++-
 t/t5591-receive-large-blobs.sh   | 114 +++++++++++++++++++++++++++++++
 11 files changed, 221 insertions(+), 3 deletions(-)
 create mode 100644 info-files.c
 create mode 100644 info-files.h
 create mode 100755 t/t5591-receive-large-blobs.sh

diff --git a/Documentation/config/receive.txt b/Documentation/config/receive.txt
index 2c070709f6..c0c04ce5cd 100644
--- a/Documentation/config/receive.txt
+++ b/Documentation/config/receive.txt
@@ -49,6 +49,11 @@ receive.fsck.skipList::
 	linkgit:git-fsck[1]. See the `fsck.skipList` documentation for
 	details.
 
+receive.largeblobsinfo::
+	When it is set to true, git-receive-pack will run with
+	"--info-large-blobs" and save large blob oids to
+	"objects/info/large-blobs".
+
 receive.keepAlive::
 	After receiving the pack from the client, `receive-pack` may
 	produce no output (if `--quiet` was specified) while processing
diff --git a/Makefile b/Makefile
index 61aadf3ce8..fb2ac97723 100644
--- a/Makefile
+++ b/Makefile
@@ -962,6 +962,7 @@ LIB_OBJS += list-objects-filter.o
 LIB_OBJS += list-objects.o
 LIB_OBJS += ll-merge.o
 LIB_OBJS += lockfile.o
+LIB_OBJS += info-files.o
 LIB_OBJS += log-tree.o
 LIB_OBJS += ls-refs.o
 LIB_OBJS += mailinfo.o
diff --git a/builtin/index-pack.c b/builtin/index-pack.c
index b9959c8aed..d194562ee5 100644
--- a/builtin/index-pack.c
+++ b/builtin/index-pack.c
@@ -1,5 +1,7 @@
 #include "builtin.h"
 #include "config.h"
+#include "lockfile.h"
+#include "info-files.h"
 #include "delta.h"
 #include "pack.h"
 #include "csum-file.h"
@@ -443,6 +445,24 @@ static int is_delta_type(enum object_type type)
 	return (type == OBJ_REF_DELTA || type == OBJ_OFS_DELTA);
 }
 
+static void save_receive_pack_infos(struct object_id *oid,
+				    enum object_type type, unsigned long size)
+{
+	switch (type) {
+	case OBJ_BLOB:
+		if (info_large_blobs_fd && size > big_file_threshold) {
+			struct strbuf buf = STRBUF_INIT;
+			strbuf_addf(&buf, "%s %"PRIuMAX"\n",
+				    oid_to_hex(oid), (uintmax_t)size);
+			xwrite(info_large_blobs_fd, buf.buf, buf.len);
+			strbuf_release(&buf);
+		}
+		return;
+	default:
+		return;
+	}
+}
+
 static void *unpack_entry_data(off_t offset, unsigned long size,
 			       enum object_type type, struct object_id *oid)
 {
@@ -486,8 +506,10 @@ static void *unpack_entry_data(off_t offset, unsigned long size,
 	if (stream.total_out != size || status != Z_STREAM_END)
 		bad_object(offset, _("inflate returned %d"), status);
 	git_inflate_end(&stream);
-	if (oid)
+	if (oid) {
 		the_hash_algo->final_oid_fn(oid, &c);
+		save_receive_pack_infos(oid, type, size);
+	}
 	return buf == fixed_buf ? NULL : buf;
 }
 
@@ -1003,6 +1025,8 @@ static struct base_data *resolve_delta(struct object_entry *delta_obj,
 		bad_object(delta_obj->idx.offset, _("failed to apply delta"));
 	hash_object_file(the_hash_algo, result_data, result_size,
 			 delta_obj->real_type, &delta_obj->idx.oid);
+	save_receive_pack_infos(&delta_obj->idx.oid, delta_obj->real_type,
+				result_size);
 	sha1_object(result_data, NULL, result_size, delta_obj->real_type,
 		    &delta_obj->idx.oid);
 
@@ -1751,6 +1775,7 @@ int cmd_index_pack(int argc, const char **argv, const char *prefix)
 	struct strbuf rev_index_name_buf = STRBUF_INIT;
 	struct pack_idx_entry **idx_objects;
 	struct pack_idx_option opts;
+	struct lock_file info_large_blobs = LOCK_INIT;
 	unsigned char pack_hash[GIT_MAX_RAWSZ];
 	unsigned foreign_nr = 1;	/* zero is a "good" value, assume bad */
 	int report_end_of_input = 0;
@@ -1870,6 +1895,8 @@ int cmd_index_pack(int argc, const char **argv, const char *prefix)
 				rev_index = 1;
 			} else if (!strcmp(arg, "--no-rev-index")) {
 				rev_index = 0;
+			} else if (!strcmp(arg, "--info-large-blobs")) {
+				info_large_blobs_fd = create_info_file(&info_large_blobs, "large-blobs");
 			} else
 				usage(index_pack_usage);
 			continue;
@@ -1940,6 +1967,8 @@ int cmd_index_pack(int argc, const char **argv, const char *prefix)
 		write_in_full(2, "\0", 1);
 	resolve_deltas();
 	conclude_pack(fix_thin_pack, curr_pack, pack_hash);
+	if (info_large_blobs_fd && commit_lock_file(&info_large_blobs))
+		die_errno(_("cannot create 'info/large-blobs'"));
 	free(ofs_deltas);
 	free(ref_deltas);
 	if (strict)
diff --git a/builtin/receive-pack.c b/builtin/receive-pack.c
index 3b9f08466c..c36588ca7b 100644
--- a/builtin/receive-pack.c
+++ b/builtin/receive-pack.c
@@ -69,6 +69,7 @@ static int quiet;
 static int prefer_ofs_delta = 1;
 static int auto_update_server_info;
 static int auto_gc = 1;
+static int info_large_blobs;
 static int reject_thin;
 static int stateless_rpc;
 static const char *service_dir;
@@ -216,6 +217,11 @@ static int receive_pack_config(const char *var, const char *value, void *cb)
 		return 0;
 	}
 
+	if (strcmp(var, "receive.largeblobsinfo") == 0) {
+		info_large_blobs = git_config_bool(var, value);
+		return 0;
+	}
+
 	if (strcmp(var, "receive.shallowupdate") == 0) {
 		shallow_update = git_config_bool(var, value);
 		return 0;
@@ -2239,6 +2245,8 @@ static const char *unpack(int err_fd, struct shallow_info *si)
 	if (ntohl(hdr.hdr_entries) < unpack_limit) {
 		strvec_push(&child.args, "unpack-objects");
 		push_header_arg(&child.args, &hdr);
+		if (info_large_blobs)
+			strvec_push(&child.args, "--info-large-blobs");
 		if (quiet)
 			strvec_push(&child.args, "-q");
 		if (fsck_objects)
@@ -2272,6 +2280,8 @@ static const char *unpack(int err_fd, struct shallow_info *si)
 			     (uintmax_t)getpid(),
 			     hostname);
 
+		if (info_large_blobs)
+			strvec_push(&child.args, "--info-large-blobs");
 		if (!quiet && err_fd)
 			strvec_push(&child.args, "--show-resolving-progress");
 		if (use_sideband)
diff --git a/builtin/unpack-objects.c b/builtin/unpack-objects.c
index 8eba632df4..159be61639 100644
--- a/builtin/unpack-objects.c
+++ b/builtin/unpack-objects.c
@@ -1,5 +1,7 @@
 #include "builtin.h"
 #include "cache.h"
+#include "lockfile.h"
+#include "info-files.h"
 #include "config.h"
 #include "object-store.h"
 #include "object.h"
@@ -375,7 +377,7 @@ static void write_stream_blob(unsigned nr, unsigned long size)
 	git_inflate_init(&zstream);
 
 	if (write_object_file_flags(&in_stream, size,
-				    type_name(OBJ_BLOB),
+				    OBJ_BLOB,
 				    &obj_list[nr].oid,
 				    HASH_STREAM))
 		die(_("failed to write object in stream"));
@@ -626,6 +628,7 @@ int cmd_unpack_objects(int argc, const char **argv, const char *prefix)
 {
 	int i;
 	struct object_id oid;
+	struct lock_file info_large_blobs = LOCK_INIT;
 
 	read_replace_refs = 0;
 
@@ -685,6 +688,10 @@ int cmd_unpack_objects(int argc, const char **argv, const char *prefix)
 				max_input_object_size = strtoumax(arg, NULL, 10);
 				continue;
 			}
+			if (!strcmp(arg, "--info-large-blobs")) {
+				info_large_blobs_fd = create_info_file(&info_large_blobs, "large-blobs");
+				continue;
+			}
 			usage(unpack_usage);
 		}
 
@@ -693,6 +700,8 @@ int cmd_unpack_objects(int argc, const char **argv, const char *prefix)
 	}
 	the_hash_algo->init_fn(&ctx);
 	unpack_all();
+	if (info_large_blobs_fd && commit_lock_file(&info_large_blobs))
+		die_errno(_("cannot create 'info/large-blobs'"));
 	the_hash_algo->update_fn(&ctx, buffer, offset);
 	the_hash_algo->final_oid_fn(&oid, &ctx);
 	if (strict) {
diff --git a/cache.h b/cache.h
index a1dc72b065..5b796c0508 100644
--- a/cache.h
+++ b/cache.h
@@ -967,6 +967,7 @@ extern char *apply_default_whitespace;
 extern char *apply_default_ignorewhitespace;
 extern const char *git_attributes_file;
 extern const char *git_hooks_path;
+extern int info_large_blobs_fd;
 extern int zlib_compression_level;
 extern int pack_compression_level;
 extern size_t packed_git_window_size;
diff --git a/environment.c b/environment.c
index b3296ce7d1..7aeb5dc2c1 100644
--- a/environment.c
+++ b/environment.c
@@ -40,6 +40,7 @@ char *apply_default_whitespace;
 char *apply_default_ignorewhitespace;
 const char *git_attributes_file;
 const char *git_hooks_path;
+int info_large_blobs_fd = 0;
 int zlib_compression_level = Z_BEST_SPEED;
 int pack_compression_level = Z_DEFAULT_COMPRESSION;
 int fsync_object_files = -1;
diff --git a/info-files.c b/info-files.c
new file mode 100644
index 0000000000..b54639e866
--- /dev/null
+++ b/info-files.c
@@ -0,0 +1,22 @@
+#include "cache.h"
+#include "lockfile.h"
+#include "info-files.h"
+
+int create_info_file(struct lock_file *lk, const char *file)
+{
+	struct strbuf path = STRBUF_INIT;
+
+	strbuf_addstr(&path, get_object_directory());
+
+	/* create info dir if not exists */
+	strbuf_addstr(&path, "/info");
+	safe_create_dir(path.buf, 1);
+
+	/* create info/large-blobs */
+	strbuf_addf(&path, "/%s", file);
+	hold_lock_file_for_update_mode(lk, path.buf, LOCK_DIE_ON_ERROR, 0444);
+
+	strbuf_release(&path);
+
+	return get_lock_file_fd(lk);
+}
diff --git a/info-files.h b/info-files.h
new file mode 100644
index 0000000000..ac6d1f501e
--- /dev/null
+++ b/info-files.h
@@ -0,0 +1,8 @@
+#ifndef INFO_FILES_H
+#define INFO_FILES_H
+
+#include "lockfile.h"
+
+int create_info_file(struct lock_file *lk, const char *file);
+
+#endif
diff --git a/object-file.c b/object-file.c
index 44ebf76063..9a081e3580 100644
--- a/object-file.c
+++ b/object-file.c
@@ -1967,6 +1967,21 @@ static int freshen_packed_object(const struct object_id *oid)
 	return 1;
 }
 
+static void save_receive_pack_infos(struct object_id *oid, char *hdr,
+				    unsigned long size)
+{
+	if (!strncmp(hdr, "blob", 4)) {
+		if (info_large_blobs_fd && size > big_file_threshold) {
+			struct strbuf buf = STRBUF_INIT;
+			strbuf_addf(&buf, "%s %"PRIuMAX"\n",
+				    oid_to_hex(oid), (uintmax_t)size);
+			xwrite(info_large_blobs_fd, buf.buf, buf.len);
+			strbuf_release(&buf);
+		}
+		return;
+	}
+}
+
 static int write_loose_object(struct object_id *oid, char *hdr,
 			      int hdrlen, const void *buf, unsigned long len,
 			      time_t mtime, unsigned flags)
@@ -2086,6 +2101,8 @@ static int write_loose_object(struct object_id *oid, char *hdr,
 			warning_errno(_("failed utime() on %s"), tmp_file.buf);
 	}
 
+	save_receive_pack_infos(oid, hdr, len);
+
 	return finalize_object_file(tmp_file.buf, filename.buf);
 }
 
@@ -2097,7 +2114,8 @@ int write_object_file_flags(const void *buf, unsigned long len,
 	int hdrlen = sizeof(hdr);
 	if (flags & HASH_STREAM) {
 		/* Generate the header */
-		hdrlen = xsnprintf(hdr, hdrlen, "%s %"PRIuMAX , type, (uintmax_t)len)+1;
+		hdrlen = format_object_header(hdr, hdrlen, type, len);
+
 		return write_loose_object(oid, hdr, hdrlen, buf, len, 0, flags);
 	}
 
diff --git a/t/t5591-receive-large-blobs.sh b/t/t5591-receive-large-blobs.sh
new file mode 100755
index 0000000000..8f2ae46ace
--- /dev/null
+++ b/t/t5591-receive-large-blobs.sh
@@ -0,0 +1,114 @@
+#!/bin/sh
+#
+# Copyright (c) 2021 Han Xin
+#
+
+test_description='Test receive large blobs when receive pack'
+
+GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME=main
+export GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME
+
+. ./test-lib.sh
+
+setup () {
+	test_when_finished "rm -rf dest.git" &&
+	git init --bare dest.git &&
+	git -C dest.git config core.bigFileThreshold 100
+	if test -n "$1"
+	then
+		git -C dest.git index-pack --stdin <$1
+	fi
+}
+
+check () {
+	test -f $1/info/large-blobs &&
+	test $(cat $1/info/large-blobs | wc -l) -eq $2
+}
+
+# usage: check_deltas <stderr_from_pack_objects> <cmp_op> <nr_deltas>
+# e.g.: check_deltas stderr -gt 0
+check_deltas() {
+	deltas=$(perl -lne '/delta (\d+)/ and print $1' "$1") &&
+	shift &&
+	if ! test "$deltas" "$@"
+	then
+		echo >&2 "unexpected number of deltas (compared $delta $*)"
+		return 1
+	fi
+}
+
+test_expect_success 'setup packfile contains large blobs' '
+	test_commit --append small small-blob &&
+	test-tool genrandom bar 128 >big-blob &&
+	test_commit --append big-one big-blob &&
+	test_commit --append big-two big-blob &&
+	test_commit --append big-three big-blob &&
+	test_commit --append big-four big-blob &&
+	git update-ref refs/heads/stage-1 HEAD &&
+	test_commit --append big-five big-blob &&
+	test_commit --append big-six big-blob &&
+	git update-ref refs/heads/stage-2 HEAD
+'
+
+test_expect_success 'pack without delta' '
+	git pack-objects --revs --progress --window=0 --stdout \
+		1>1.pack 2>stderr <<-\EOF &&
+		stage-1
+		EOF
+	check_deltas stderr = 0
+'
+
+test_expect_success 'pack with REF_DELTA' '
+	git -c pack.threads=1 pack-objects --revs --progress --thin --stdout \
+		1>2.pack 2>stderr <<-\EOF &&
+		^stage-1
+		stage-2
+		EOF
+	check_deltas stderr -gt 0
+'
+
+test_expect_success 'pack with OFS_DELTA' '
+	git -c pack.threads=1 pack-objects --revs --progress --thin --delta-base-offset --stdout \
+		1>3.pack 2>stderr <<-\EOF &&
+		^stage-1
+		stage-2
+		EOF
+	check_deltas stderr -gt 0
+'
+
+test_save_receive_pack_info () {
+	pack=$1
+	sum=$2
+	base=$3
+	test_expect_success 'unpack-objects with --info-large-blobs' '
+		setup $base &&
+		git -C dest.git unpack-objects --info-large-blobs <${pack} &&
+		check dest.git/objects $sum
+	'
+
+	test_expect_success 'unpack-objects without --info-large-blobs' '
+		setup $base &&
+		git -C dest.git unpack-objects <${pack} &&
+		! test -f dest.git/objects/info/large-blobs
+	'
+
+	test_expect_success 'index-pack with --info-large-blobs' '
+		setup $base &&
+		git -C dest.git index-pack --fix-thin --info-large-blobs --stdin <${pack} &&
+		check dest.git/objects $sum
+	'
+
+	test_expect_success 'index-pack without --info-large-blobs' '
+		setup $base &&
+		git -C dest.git index-pack --fix-thin --stdin <${pack} &&
+		! test -f dest.git/objects/info/large-blobs
+	'
+}
+
+test_save_receive_pack_info 1.pack 4
+
+test_save_receive_pack_info 2.pack 2 1.pack
+
+test_save_receive_pack_info 3.pack 2 1.pack
+
+test_done
-- 
patchwork
