From 167bdc1ba19c6e407a773087383f5b8d29f0c667 Mon Sep 17 00:00:00 2001
From: Han Xin <hanxin.hx@alibaba-inc.com>
Date: Mon, 29 Mar 2021 15:06:51 +0800
Subject: [PATCH 45/47] crypto: add new crypto algo AES_X4

AES_X4(algo type 3) will repeat each byte of seq for 4 times, and
encrypt 64 bytes once. In this mode, we only need 1/4 of calls to do
encryption.

Signed-off-by: Han Xin <hanxin.hx@alibaba-inc.com>
---
 crypto.c                        | 90 ++++++++++++++++++++++++---------
 crypto.h                        |  3 +-
 t/t0940/once-0001-crypto.sh     | 48 ++++++++++++++++++
 t/t0940/once-0002-crypto-map.sh | 40 +++++++++++++++
 4 files changed, 155 insertions(+), 26 deletions(-)

diff --git a/crypto.c b/crypto.c
index d9c4582184..0e7643b9c3 100644
--- a/crypto.c
+++ b/crypto.c
@@ -58,6 +58,8 @@ static enum agit_crypto_algo crypto_new_algorithim(enum agit_crypto_algo algo)
 		/* fallthrough */
 	case GIT_CRYPTO_ALGORITHM_AES:
 		/* fallthrough */
+	case GIT_CRYPTO_ALGORITHM_AES_X4:
+		/* fallthrough */
 	case GIT_CRYPTO_ALGORITHM_EASY_BENCHMARK:
 		/* fallthrough */
 	case GIT_CRYPTO_ALGORITHM_EASY_AES:
@@ -80,7 +82,7 @@ static int gen_sec_sequence_benchmark(git_cryptor *cryptor, unsigned char *seq,
 	/* mix test writes 16 bytes */
 	assert(len >= ret);
 
-	if (pos_n != 0 && pos_n == cryptor->pos_n_last)
+	if (pos_n && pos_n == cryptor->pos_n_last)
 		return ret;
 	else
 		cryptor->pos_n_last = pos_n;
@@ -103,7 +105,7 @@ static int gen_sec_sequence_aes(git_cryptor *cryptor, unsigned char *seq,
 	/* aes writes 16 bytes */
 	assert(len >= ret);
 
-	if (pos_n != 0 && pos_n == cryptor->pos_n_last)
+	if (pos_n && pos_n == cryptor->pos_n_last)
 		return ret;
 	else
 		cryptor->pos_n_last = pos_n;
@@ -117,6 +119,38 @@ static int gen_sec_sequence_aes(git_cryptor *cryptor, unsigned char *seq,
 	return ret;
 }
 
+/*
+ * Setup secret sequence for each block, and returns length of
+ * sequence generated.
+ */
+static int gen_sec_sequence_aes_x4(git_cryptor *cryptor,
+					 unsigned char *seq, uint32_t len)
+{
+	/* pos = cryptor->byte_counter / 64 */
+	uint32_t pos_n = htonl(cryptor->byte_counter >> 6);
+	int ret = 64, ciphertext_len, i, j;
+	unsigned char cipher[16];
+	/* aes mix writes 64 bytes */
+	assert(len >= ret);
+
+	if (pos_n && pos_n == cryptor->pos_n_last)
+		return ret;
+	else
+		cryptor->pos_n_last = pos_n;
+
+	memcpy(cryptor->nonce + NONCE_LEN, &pos_n, sizeof(uint32_t));
+
+	if (1 != EVP_EncryptUpdate(cryptor->ctx, cipher, &ciphertext_len,
+				   (const unsigned char *)cryptor->nonce, sizeof(cipher)))
+		die("aes encrypt nonce failed");
+	assert(ciphertext_len == sizeof(cipher));
+	for (i = 0; i < sizeof(cipher); i ++) {
+		j = i << 2;
+		seq[j] = seq[j + 1] = seq[j + 2] = seq[j + 3] = cipher[i];
+	}
+	return ret;
+}
+
 static void git_decrypt(git_cryptor *cryptor, const unsigned char *in,
 			unsigned char *out, size_t avail_in, size_t avail_out)
 {
@@ -130,20 +164,18 @@ static void git_decrypt(git_cryptor *cryptor, const unsigned char *in,
 				sizeof(cryptor->secret_sequence));
 			pos = cryptor->byte_counter & (sec_seq_len - 1);
 			sec_seq_init = 1;
-		} else if (pos == 0)
+		} else
 			sec_seq_len = cryptor->gen_sec_sequence(
 				cryptor, cryptor->secret_sequence,
 				sizeof(cryptor->secret_sequence));
 
 		post_avail = (sec_seq_len - pos) < avail ? sec_seq_len - pos :
 							   avail;
-
 		for (i = 0; i < post_avail; i++) {
 			/* encrypt one byte */
 			*out++ = *in++ ^ cryptor->secret_sequence[
 				pos++ & (sec_seq_len - 1)];
 		}
-
 		pos = 0;
 		cryptor->byte_counter += i;
 		avail -= i;
@@ -202,6 +234,26 @@ static int git_crypto_get_secret(unsigned char **secret)
 	return len;
 }
 
+static void git_crypto_init_aes(git_cryptor *cryptor, unsigned char *secret, int secret_len)
+{
+	if (!(cryptor->ctx = EVP_CIPHER_CTX_new()))
+		die("new aes ctx failed");
+
+	if (secret_len >= 32) {
+		if (!(EVP_EncryptInit_ex(cryptor->ctx, EVP_aes_256_ecb(), NULL,
+					 secret, NULL)))
+			die("setup aes256 encrypt key failed");
+	} else if (secret_len >= 24) {
+		if (!(EVP_EncryptInit_ex(cryptor->ctx, EVP_aes_192_ecb(), NULL,
+					 secret, NULL)))
+			die("setup aes192 encrypt key failed");
+	} else {
+		if (!(EVP_EncryptInit_ex(cryptor->ctx, EVP_aes_128_ecb(), NULL,
+					 secret, NULL)))
+			die("setup aes128 encrypt key failed");
+	}
+}
+
 /* set up crypto method */
 static void git_crypto_setup(git_cryptor *cryptor)
 {
@@ -227,29 +279,17 @@ static void git_crypto_setup(git_cryptor *cryptor)
 	case GIT_CRYPTO_ALGORITHM_AES:
 	case GIT_CRYPTO_ALGORITHM_EASY_AES:
 		{
-		if (!(cryptor->ctx = EVP_CIPHER_CTX_new()))
-			die("new aes ctx failed");
-
-		if (secret_len >= 32) {
-			if (!(EVP_EncryptInit_ex(cryptor->ctx,
-						 EVP_aes_256_ecb(), NULL,
-						 secret, NULL)))
-				die("setup aes256 encrypt key failed");
-		} else if (secret_len >= 24) {
-			if (!(EVP_EncryptInit_ex(cryptor->ctx,
-						 EVP_aes_192_ecb(), NULL,
-						 secret, NULL)))
-				die("setup aes192 encrypt key failed");
-		} else {
-			if (!(EVP_EncryptInit_ex(cryptor->ctx,
-						 EVP_aes_128_ecb(), NULL,
-						 secret, NULL)))
-				die("setup aes128 encrypt key failed");
-		}
-
+		git_crypto_init_aes(cryptor, secret, secret_len);
 		cryptor->gen_sec_sequence = &gen_sec_sequence_aes;
 		}
 		break;
+	case GIT_CRYPTO_ALGORITHM_AES_X4:
+		{
+		memset(cryptor->secret_sequence, 0, sizeof(cryptor->secret_sequence));
+		git_crypto_init_aes(cryptor, secret, secret_len);
+		cryptor->gen_sec_sequence = &gen_sec_sequence_aes_x4;
+		}
+		break;
 	default:
 		die("crypto cipher type %d not supported", cryptor->algorithm);
 	}
diff --git a/crypto.h b/crypto.h
index 5336abc411..a49e63cb2a 100644
--- a/crypto.h
+++ b/crypto.h
@@ -49,6 +49,7 @@ enum agit_crypto_algo {
 	GIT_CRYPTO_ALGORITHM_BENCHMARK = 1, /* test only, do not use in
 					       production */
 	GIT_CRYPTO_ALGORITHM_AES = 2,
+	GIT_CRYPTO_ALGORITHM_AES_X4 = 3,
 
 	/* Algorithm 64 - 95 (10x xxxx), which used normal header,
 	 * and the 6/7th bytes are used as 2-byte salt. */
@@ -79,7 +80,7 @@ typedef struct git_cryptor {
 	/* Must allocate secret_sequence longer enough for HASH function.
 	 * SHA256 hash needs 32 bytes.
 	 */
-	unsigned char secret_sequence[32];
+	unsigned char secret_sequence[64];
 	uint32_t pos_n_last;
 	EVP_CIPHER_CTX *ctx;
 
diff --git a/t/t0940/once-0001-crypto.sh b/t/t0940/once-0001-crypto.sh
index 3d3df99b63..072c6c2816 100644
--- a/t/t0940/once-0001-crypto.sh
+++ b/t/t0940/once-0001-crypto.sh
@@ -72,6 +72,24 @@ test_expect_success 'encrypt text file using algorithm 2' '
 	test_cmp expect-z-2 actual
 '
 
+test_expect_success 'encrypt text file using algorithm 3' '
+	cat >expect-z-3 <<-\EOF &&
+	0000000 45 4e 43 00 83 00 00 00 72 61 6e 64 6f 6d 5f 6e    | ENC.....random_n |
+	0000016 6f 6e 63 65 f2 8b 41 c2 6a 6e 6e 70 9e e7 00 e0    | once..A.jnnp.... |
+	0000032 bf 3c 94 77 b5 94 52 b1 b0                         | .<.w..R..        |
+	EOF
+
+	GIT_TEST_CRYPTO_ALGORITHM_TYPE=3 GIT_TRACE_CRYPTO=1 \
+		test-tool agit-crypto -z \
+		--secret c2VjcmV0LXRva2Vu \
+		-i text-file -o text-file.z.3 &&
+	test-tool agit-od <text-file.z.3 >actual &&
+
+	! test_cmp expect-z-2 actual &&
+
+	test_cmp expect-z-3 actual
+'
+
 test_expect_success 'encrypt text file using algorithm 64' '
 	show_lo_header <expect-z-1 >expect-z-64 &&
 	printf c0 >>expect-z-64 &&
@@ -255,6 +273,15 @@ test_expect_success 'decrypt text-file.z.2' '
 	test_cmp text-file text-file.x.2
 '
 
+test_expect_success 'decrypt text-file.z.3' '
+	GIT_TRACE_CRYPTO=1 \
+		test-tool agit-crypto -x \
+		--secret c2VjcmV0LXRva2VuAAA= \
+		-i text-file.z.3 -o text-file.x.3 &&
+
+	test_cmp text-file text-file.x.3
+'
+
 test_expect_success 'decrypt text-file.z.64' '
 	GIT_TRACE_CRYPTO=1 \
 		test-tool agit-crypto -x \
@@ -359,6 +386,19 @@ test_expect_success NEED_GNU_DD 'encrypt large binary (algo 2)' '
 	test_cmp expect actual
 '
 
+test_expect_success NEED_GNU_DD 'encrypt large binary (algo 3)' '
+	GIT_TEST_CRYPTO_ALGORITHM_TYPE=3 GIT_TRACE_CRYPTO=1 \
+		test-tool agit-crypto -z \
+		--secret c2VjcmV0LXRva2VuAA== \
+		-i bin-file -o bin-file.z.3 &&
+	show_lo_header <bin-file.z.3 | test-tool agit-od >actual &&
+	cat >expect <<-\EOF &&
+	0000000 45 4e 43 00 83 00 00 00 72 61 6e 64 6f 6d 5f 6e    | ENC.....random_n |
+	0000016 6f 6e 63 65                                        | once             |
+	EOF
+	test_cmp expect actual
+'
+
 test_expect_success NEED_GNU_DD 'encrypt large binary (algo 64)' '
 	GIT_TEST_CRYPTO_ALGORITHM_TYPE=64 GIT_TRACE_CRYPTO=1 \
 		test-tool agit-crypto -z \
@@ -401,6 +441,14 @@ test_expect_success NEED_GNU_DD 'decrypt bin-file.z.2' '
 	test_cmp bin-file bin-file.x.2
 '
 
+test_expect_success NEED_GNU_DD 'decrypt bin-file.z.3' '
+	GIT_TRACE_CRYPTO=1 \
+		test-tool agit-crypto -x \
+		--secret c2VjcmV0LXRva2VuAA== \
+		-i bin-file.z.3 -o bin-file.x.3 &&
+	test_cmp bin-file bin-file.x.3
+'
+
 test_expect_success NEED_GNU_DD 'decrypt bin-file.z.64' '
 	GIT_TRACE_CRYPTO=1 \
 		test-tool agit-crypto -x \
diff --git a/t/t0940/once-0002-crypto-map.sh b/t/t0940/once-0002-crypto-map.sh
index c36802aa92..98d474b6e7 100644
--- a/t/t0940/once-0002-crypto-map.sh
+++ b/t/t0940/once-0002-crypto-map.sh
@@ -72,6 +72,24 @@ test_expect_success 'encrypt text file using algorithm 2 (with --mmap)' '
 	test_cmp expect-z-2 actual
 '
 
+test_expect_success 'encrypt text file using algorithm 3 (with --mmap)' '
+	cat >expect-z-3 <<-\EOF &&
+	0000000 45 4e 43 00 83 00 00 00 72 61 6e 64 6f 6d 5f 6e    | ENC.....random_n |
+	0000016 6f 6e 63 65 f2 8b 41 c2 6a 6e 6e 70 9e e7 00 e0    | once..A.jnnp.... |
+	0000032 bf 3c 94 77 b5 94 52 b1 b0                         | .<.w..R..        |
+	EOF
+
+	GIT_TEST_CRYPTO_ALGORITHM_TYPE=3 GIT_TRACE_CRYPTO=1 \
+		test-tool agit-crypto --mmap -z \
+		--secret c2VjcmV0LXRva2Vu \
+		-i text-file -o text-file.z.3 &&
+	test-tool agit-od <text-file.z.3 >actual &&
+
+	! test_cmp expect-z-2 actual &&
+
+	test_cmp expect-z-3 actual
+'
+
 test_expect_success 'encrypt text file using algorithm 64 (with --mmap)' '
 	show_lo_header <expect-z-1 >expect-z-64 &&
 	printf c0 >>expect-z-64 &&
@@ -255,6 +273,15 @@ test_expect_success 'decrypt text-file.z.2 (with --mmap)' '
 	test_cmp text-file text-file.x.2
 '
 
+test_expect_success 'decrypt text-file.z.3 (with --mmap)' '
+	GIT_TRACE_CRYPTO=1 \
+		test-tool agit-crypto --mmap -x \
+		--secret c2VjcmV0LXRva2VuAAA= \
+		-i text-file.z.3 -o text-file.x.3 &&
+
+	test_cmp text-file text-file.x.3
+'
+
 test_expect_success 'decrypt text-file.z.64 (with --mmap)' '
 	GIT_TRACE_CRYPTO=1 \
 		test-tool agit-crypto --mmap -x \
@@ -359,6 +386,19 @@ test_expect_success NEED_GNU_DD 'encrypt large binary (algo 2, with --mmap)' '
 	test_cmp expect actual
 '
 
+test_expect_success NEED_GNU_DD 'encrypt large binary (algo 3, with --mmap)' '
+	GIT_TEST_CRYPTO_ALGORITHM_TYPE=3 GIT_TRACE_CRYPTO=1 \
+		test-tool agit-crypto --mmap -z \
+		--secret c2VjcmV0LXRva2VuAA== \
+		-i bin-file -o bin-file.z.3 &&
+	show_lo_header <bin-file.z.3 | test-tool agit-od >actual &&
+	cat >expect <<-\EOF &&
+	0000000 45 4e 43 00 83 00 00 00 72 61 6e 64 6f 6d 5f 6e    | ENC.....random_n |
+	0000016 6f 6e 63 65                                        | once             |
+	EOF
+	test_cmp expect actual
+'
+
 test_expect_success NEED_GNU_DD 'encrypt large binary (algo 64, with --mmap)' '
 	GIT_TEST_CRYPTO_ALGORITHM_TYPE=64 GIT_TRACE_CRYPTO=1 \
 		test-tool agit-crypto --mmap -z \
-- 
patchwork
