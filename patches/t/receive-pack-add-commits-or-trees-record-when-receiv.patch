From 7b789ce225b902b77f8b2e98beb38fef6f5735ca Mon Sep 17 00:00:00 2001
From: Han Xin <hanxin.hx@alibaba-inc.com>
Date: Wed, 15 Dec 2021 17:55:38 +0800
Subject: [PATCH 57/57] receive-pack: add commits or trees record when
 receive-pack

When 'receive.commitsinfo' or 'receive.treesinfo' is true, commits or
trees oids will be save to info/commits or info/trees.

Signed-off-by: Han Xin <hanxin.hx@alibaba-inc.com>
---
 Documentation/config/receive.txt |   8 ++
 builtin/index-pack.c             |  26 ++++++
 builtin/receive-pack.c           |  20 +++++
 builtin/unpack-objects.c         |  14 ++++
 cache.h                          |   2 +
 environment.c                    |   2 +
 object-file.c                    |  18 ++++
 t/t5592-receive-and-info.sh      | 138 +++++++++++++++++++++++++++++++
 8 files changed, 228 insertions(+)
 create mode 100755 t/t5592-receive-and-info.sh

diff --git a/Documentation/config/receive.txt b/Documentation/config/receive.txt
index c0c04ce5cd..c65f5a1316 100644
--- a/Documentation/config/receive.txt
+++ b/Documentation/config/receive.txt
@@ -54,6 +54,14 @@ receive.largeblobsinfo::
 	"--info-large-blobs" and save large blob oids to
 	"objects/info/large-blobs".
 
+receive.commitsinfo::
+	When it is set to true, git-receive-pack will run with
+	"--info-commits" and save commit oids to "objects/info/commits".
+
+receive.treesinfo::
+	When it is set to true, git-receive-pack will run with
+	"--info-trees" and save tree oids to "objects/info/trees".
+
 receive.keepAlive::
 	After receiving the pack from the client, `receive-pack` may
 	produce no output (if `--quiet` was specified) while processing
diff --git a/builtin/index-pack.c b/builtin/index-pack.c
index d194562ee5..23a09ea947 100644
--- a/builtin/index-pack.c
+++ b/builtin/index-pack.c
@@ -458,6 +458,22 @@ static void save_receive_pack_infos(struct object_id *oid,
 			strbuf_release(&buf);
 		}
 		return;
+	case OBJ_COMMIT:
+		if (info_commits_fd) {
+			struct strbuf buf = STRBUF_INIT;
+			strbuf_addf(&buf, "%s\n", oid_to_hex(oid));
+			xwrite(info_commits_fd, buf.buf, buf.len);
+			strbuf_release(&buf);
+		}
+		return;
+	case OBJ_TREE:
+		if (info_trees_fd) {
+			struct strbuf buf = STRBUF_INIT;
+			strbuf_addf(&buf, "%s\n", oid_to_hex(oid));
+			xwrite(info_trees_fd, buf.buf, buf.len);
+			strbuf_release(&buf);
+		}
+		return;
 	default:
 		return;
 	}
@@ -1776,6 +1792,8 @@ int cmd_index_pack(int argc, const char **argv, const char *prefix)
 	struct pack_idx_entry **idx_objects;
 	struct pack_idx_option opts;
 	struct lock_file info_large_blobs = LOCK_INIT;
+	struct lock_file info_commits = LOCK_INIT;
+	struct lock_file info_trees = LOCK_INIT;
 	unsigned char pack_hash[GIT_MAX_RAWSZ];
 	unsigned foreign_nr = 1;	/* zero is a "good" value, assume bad */
 	int report_end_of_input = 0;
@@ -1897,6 +1915,10 @@ int cmd_index_pack(int argc, const char **argv, const char *prefix)
 				rev_index = 0;
 			} else if (!strcmp(arg, "--info-large-blobs")) {
 				info_large_blobs_fd = create_info_file(&info_large_blobs, "large-blobs");
+			} else if (!strcmp(arg, "--info-commits")) {
+				info_commits_fd = create_info_file(&info_commits, "commits");
+			} else if (!strcmp(arg, "--info-trees")) {
+				info_trees_fd = create_info_file(&info_trees, "trees");
 			} else
 				usage(index_pack_usage);
 			continue;
@@ -1969,6 +1991,10 @@ int cmd_index_pack(int argc, const char **argv, const char *prefix)
 	conclude_pack(fix_thin_pack, curr_pack, pack_hash);
 	if (info_large_blobs_fd && commit_lock_file(&info_large_blobs))
 		die_errno(_("cannot create 'info/large-blobs'"));
+	if (info_commits_fd && commit_lock_file(&info_commits))
+		die_errno(_("cannot create 'info/commits'"));
+	if (info_trees_fd && commit_lock_file(&info_trees))
+		die_errno(_("cannot create 'info/trees'"));
 	free(ofs_deltas);
 	free(ref_deltas);
 	if (strict)
diff --git a/builtin/receive-pack.c b/builtin/receive-pack.c
index c36588ca7b..285faf5521 100644
--- a/builtin/receive-pack.c
+++ b/builtin/receive-pack.c
@@ -70,6 +70,8 @@ static int prefer_ofs_delta = 1;
 static int auto_update_server_info;
 static int auto_gc = 1;
 static int info_large_blobs;
+static int info_commits;
+static int info_trees;
 static int reject_thin;
 static int stateless_rpc;
 static const char *service_dir;
@@ -222,6 +224,16 @@ static int receive_pack_config(const char *var, const char *value, void *cb)
 		return 0;
 	}
 
+	if (strcmp(var, "receive.commitsinfo") == 0) {
+		info_commits = git_config_bool(var, value);
+		return 0;
+	}
+
+	if (strcmp(var, "receive.treesinfo") == 0) {
+		info_trees = git_config_bool(var, value);
+		return 0;
+	}
+
 	if (strcmp(var, "receive.shallowupdate") == 0) {
 		shallow_update = git_config_bool(var, value);
 		return 0;
@@ -2247,6 +2259,10 @@ static const char *unpack(int err_fd, struct shallow_info *si)
 		push_header_arg(&child.args, &hdr);
 		if (info_large_blobs)
 			strvec_push(&child.args, "--info-large-blobs");
+		if (info_commits)
+			strvec_push(&child.args, "--info-commits");
+		if (info_trees)
+			strvec_push(&child.args, "--info-trees");
 		if (quiet)
 			strvec_push(&child.args, "-q");
 		if (fsck_objects)
@@ -2282,6 +2298,10 @@ static const char *unpack(int err_fd, struct shallow_info *si)
 
 		if (info_large_blobs)
 			strvec_push(&child.args, "--info-large-blobs");
+		if (info_commits)
+			strvec_push(&child.args, "--info-commits");
+		if (info_trees)
+			strvec_push(&child.args, "--info-trees");
 		if (!quiet && err_fd)
 			strvec_push(&child.args, "--show-resolving-progress");
 		if (use_sideband)
diff --git a/builtin/unpack-objects.c b/builtin/unpack-objects.c
index 159be61639..ebca744904 100644
--- a/builtin/unpack-objects.c
+++ b/builtin/unpack-objects.c
@@ -629,6 +629,8 @@ int cmd_unpack_objects(int argc, const char **argv, const char *prefix)
 	int i;
 	struct object_id oid;
 	struct lock_file info_large_blobs = LOCK_INIT;
+	struct lock_file info_commits = LOCK_INIT;
+	struct lock_file info_trees = LOCK_INIT;
 
 	read_replace_refs = 0;
 
@@ -692,6 +694,14 @@ int cmd_unpack_objects(int argc, const char **argv, const char *prefix)
 				info_large_blobs_fd = create_info_file(&info_large_blobs, "large-blobs");
 				continue;
 			}
+			if (!strcmp(arg, "--info-commits")) {
+				info_commits_fd = create_info_file(&info_commits, "commits");
+				continue;
+			}
+			if (!strcmp(arg, "--info-trees")) {
+				info_trees_fd = create_info_file(&info_trees, "trees");
+				continue;
+			}
 			usage(unpack_usage);
 		}
 
@@ -702,6 +712,10 @@ int cmd_unpack_objects(int argc, const char **argv, const char *prefix)
 	unpack_all();
 	if (info_large_blobs_fd && commit_lock_file(&info_large_blobs))
 		die_errno(_("cannot create 'info/large-blobs'"));
+	if (info_commits_fd && commit_lock_file(&info_commits))
+		die_errno(_("cannot create 'info/commits'"));
+	if (info_trees_fd && commit_lock_file(&info_trees))
+		die_errno(_("cannot create 'info/trees'"));
 	the_hash_algo->update_fn(&ctx, buffer, offset);
 	the_hash_algo->final_oid_fn(&oid, &ctx);
 	if (strict) {
diff --git a/cache.h b/cache.h
index 5b796c0508..e435f24668 100644
--- a/cache.h
+++ b/cache.h
@@ -968,6 +968,8 @@ extern char *apply_default_ignorewhitespace;
 extern const char *git_attributes_file;
 extern const char *git_hooks_path;
 extern int info_large_blobs_fd;
+extern int info_commits_fd;
+extern int info_trees_fd;
 extern int zlib_compression_level;
 extern int pack_compression_level;
 extern size_t packed_git_window_size;
diff --git a/environment.c b/environment.c
index 7aeb5dc2c1..377ab1347a 100644
--- a/environment.c
+++ b/environment.c
@@ -41,6 +41,8 @@ char *apply_default_ignorewhitespace;
 const char *git_attributes_file;
 const char *git_hooks_path;
 int info_large_blobs_fd = 0;
+int info_commits_fd = 0;
+int info_trees_fd = 0;
 int zlib_compression_level = Z_BEST_SPEED;
 int pack_compression_level = Z_DEFAULT_COMPRESSION;
 int fsync_object_files = -1;
diff --git a/object-file.c b/object-file.c
index 9a081e3580..b9be564e2d 100644
--- a/object-file.c
+++ b/object-file.c
@@ -1980,6 +1980,24 @@ static void save_receive_pack_infos(struct object_id *oid, char *hdr,
 		}
 		return;
 	}
+	if (!strncmp(hdr, "commit", 6)) {
+		if (info_commits_fd) {
+			struct strbuf buf = STRBUF_INIT;
+			strbuf_addf(&buf, "%s\n", oid_to_hex(oid));
+			xwrite(info_commits_fd, buf.buf, buf.len);
+			strbuf_release(&buf);
+		}
+		return;
+	}
+	if (!strncmp(hdr, "tree", 4)) {
+		if (info_trees_fd) {
+			struct strbuf buf = STRBUF_INIT;
+			strbuf_addf(&buf, "%s\n", oid_to_hex(oid));
+			xwrite(info_trees_fd, buf.buf, buf.len);
+			strbuf_release(&buf);
+		}
+		return;
+	}
 }
 
 static int write_loose_object(struct object_id *oid, char *hdr,
diff --git a/t/t5592-receive-and-info.sh b/t/t5592-receive-and-info.sh
new file mode 100755
index 0000000000..1ebf0d60b7
--- /dev/null
+++ b/t/t5592-receive-and-info.sh
@@ -0,0 +1,138 @@
+#!/bin/sh
+#
+# Copyright (c) 2021 Han Xin
+#
+
+test_description='Test info commits and trees when receive pack'
+
+GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME=main
+export GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME
+
+. ./test-lib.sh
+
+setup () {
+	test_when_finished "rm -rf dest.git" &&
+	git init --bare dest.git &&
+	git -C dest.git config core.bigFileThreshold $1 &&
+	if test -n "$2"
+	then
+		git -C dest.git index-pack --stdin <$2
+	fi
+}
+
+check () {
+	test -f $1/info/$2 &&
+	test $(cat $1/info/$2 | wc -l) -eq $3
+}
+
+# usage: check_deltas <stderr_from_pack_objects> <cmp_op> <nr_deltas>
+# e.g.: check_deltas stderr -gt 0
+check_deltas() {
+	deltas=$(perl -lne '/delta (\d+)/ and print $1' "$1") &&
+	shift &&
+	if ! test "$deltas" "$@"
+	then
+		echo >&2 "unexpected number of deltas (compared $delta $*)"
+		return 1
+	fi
+}
+
+check_thin() {
+	test_must_fail git index-pack --stdin <$1 2>stderr &&
+	test_i18ngrep "unresolved deltas" stderr
+}
+
+test_expect_success 'setup' '
+	test_commit --append aaaa file1 &&
+	test_commit --append bbbb file2 &&
+	test_commit --append cccc file3 &&
+	test_commit --append dddd file4 &&
+	git update-ref refs/heads/stage-1 HEAD &&
+	test_commit --append eeee file5 &&
+	test_commit --append ffff file6 &&
+	git update-ref refs/heads/stage-2 HEAD
+'
+
+test_expect_success 'pack without delta' '
+	git pack-objects --revs --progress --window=0 --stdout \
+		1>1.pack 2>stderr <<-\EOF &&
+		stage-1
+		EOF
+	check_deltas stderr = 0
+'
+
+test_expect_success 'pack with REF_DELTA' '
+	git -c pack.threads=1 pack-objects --revs --progress --thin --stdout \
+		1>2.pack 2>stderr <<-\EOF &&
+		^stage-1
+		stage-2
+		EOF
+	check_deltas stderr -ge 2 &&
+	check_thin 2.pack
+'
+
+test_expect_success 'pack with OFS_DELTA' '
+	git -c pack.threads=1 pack-objects --revs --progress --thin --delta-base-offset --stdout \
+		1>3.pack 2>stderr <<-\EOF &&
+		^stage-1
+		stage-2
+		EOF
+	check_deltas stderr -ge 2 &&
+	check_thin 3.pack
+'
+
+test_save_receive_pack_info () {
+	big_file_threshold=$1
+	pack=$2
+	type=$3
+	sum=$4
+	base=$5
+
+	test_expect_success "================ Setup bigFileThreshold $1 ================" '
+		test -n "$1"
+	'
+
+	test_expect_success "unpack-objects $pack with --info-$type" '
+		setup $big_file_threshold $base &&
+		git -C dest.git unpack-objects --info-$type <${pack} &&
+		check dest.git/objects $type $sum
+	'
+
+	test_expect_success "unpack-objects $pack without --info-$type" '
+		setup $big_file_threshold $base &&
+		git -C dest.git unpack-objects <${pack} &&
+		! test -f dest.git/objects/info/$type
+	'
+
+	test_expect_success "index-pack $pack with --info-$type" '
+		setup $big_file_threshold $base &&
+		git -C dest.git index-pack --fix-thin --info-$type --stdin <${pack} &&
+		check dest.git/objects $type $sum
+	'
+
+	test_expect_success "index-pack $pack without --info-$type" '
+		setup $big_file_threshold $base &&
+		git -C dest.git index-pack --fix-thin --stdin <${pack} &&
+		! test -f dest.git/objects/info/$type
+	'
+}
+
+
+test_save_receive_pack_info 2 1.pack commits 4
+test_save_receive_pack_info 20m 1.pack commits 4
+
+test_save_receive_pack_info 2 1.pack trees 4
+test_save_receive_pack_info 20m 1.pack trees 4
+
+test_save_receive_pack_info 2 2.pack commits 2 1.pack
+test_save_receive_pack_info 20m 2.pack commits 2 1.pack
+
+test_save_receive_pack_info 2 2.pack trees 2 1.pack
+test_save_receive_pack_info 20m 2.pack trees 2 1.pack
+
+test_save_receive_pack_info 2 3.pack commits 2 1.pack
+test_save_receive_pack_info 20m 3.pack commits 2 1.pack
+test_save_receive_pack_info 2 3.pack trees 2 1.pack
+test_save_receive_pack_info 20m 3.pack trees 2 1.pack
+
+test_done
-- 
patchwork
