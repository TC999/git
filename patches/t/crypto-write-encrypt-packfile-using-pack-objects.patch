From a7f807c47f00c706be620c9c6d909c904b93c681 Mon Sep 17 00:00:00 2001
From: Han Xin <hanxin.hx@alibaba-inc.com>
Date: Thu, 7 Jan 2021 17:11:22 +0800
Subject: [PATCH 34/51] crypto: write encrypt packfile using pack-objects

When writting packfile, we call `hashwrite()`.  By using an enhanced
writer `hashwrite_try_encrypt()`, we can write encrypt packfile by
"git-pack-object".

Add new test cases for read/write encrypted packfile in t0940.

Signed-off-by: Han Xin <hanxin.hx@alibaba-inc.com>
Signed-off-by: Jiang Xin <zhiyou.jx@alibaba-inc.com>
---
 builtin/fast-import.c                       |   2 +-
 builtin/pack-objects.c                      |  40 +++---
 bulk-checkin.c                              |   6 +-
 csum-file.c                                 |  78 ++++++++---
 csum-file.h                                 |   6 +
 object-file.c                               |   6 +
 pack-write.c                                |  36 ++++-
 pack.h                                      |  16 ++-
 packfile.c                                  |   7 +
 packfile.h                                  |   2 +
 t/t0940-crypto-repository.sh                |  16 +++
 t/t0940/test-0020-read-write-packfile.sh    |  94 +++++++++++++
 t/t0940/test-0021-fast-export-and-import.sh | 146 ++++++++++++++++++++
 13 files changed, 404 insertions(+), 51 deletions(-)
 create mode 100644 t/t0940/test-0020-read-write-packfile.sh
 create mode 100644 t/t0940/test-0021-fast-export-and-import.sh

diff --git a/builtin/fast-import.c b/builtin/fast-import.c
index 28d3193c38..2bc1773034 100644
--- a/builtin/fast-import.c
+++ b/builtin/fast-import.c
@@ -761,7 +761,7 @@ static void start_packfile(void)
 	pack_file = hashfd(pack_fd, p->pack_name);
 
 	pack_data = p;
-	pack_size = write_pack_header(pack_file, 0);
+	pack_size = write_pack_header_no_encrypt(pack_file, 0);
 	object_count = 0;
 
 	REALLOC_ARRAY(all_packs, pack_id + 1);
diff --git a/builtin/pack-objects.c b/builtin/pack-objects.c
index 014dcd4bc9..9f1ef4b12d 100644
--- a/builtin/pack-objects.c
+++ b/builtin/pack-objects.c
@@ -356,7 +356,7 @@ static unsigned long write_large_blob_data(struct git_istream *st, struct hashfi
 			stream.next_out = obuf;
 			stream.avail_out = sizeof(obuf);
 			zret = git_deflate(&stream, readlen ? 0 : Z_FINISH);
-			hashwrite(f, obuf, stream.next_out - obuf);
+			hashwrite_try_encrypt(f, obuf, stream.next_out - obuf);
 			olen += stream.next_out - obuf;
 		}
 		if (stream.avail_in)
@@ -414,7 +414,7 @@ static void copy_pack_data(struct hashfile *f,
 		in = use_pack(p, w_curs, offset, &avail);
 		if (avail > len)
 			avail = (unsigned long)len;
-		hashwrite(f, in, avail);
+		hashwrite_try_encrypt(f, in, avail);
 		offset += avail;
 		len -= avail;
 	}
@@ -506,8 +506,8 @@ static unsigned long write_no_reuse_object(struct hashfile *f, struct object_ent
 			free(buf);
 			return 0;
 		}
-		hashwrite(f, header, hdrlen);
-		hashwrite(f, dheader + pos, sizeof(dheader) - pos);
+		hashwrite_try_encrypt(f, header, hdrlen);
+		hashwrite_try_encrypt(f, dheader + pos, sizeof(dheader) - pos);
 		hdrlen += sizeof(dheader) - pos;
 	} else if (type == OBJ_REF_DELTA) {
 		/*
@@ -520,8 +520,8 @@ static unsigned long write_no_reuse_object(struct hashfile *f, struct object_ent
 			free(buf);
 			return 0;
 		}
-		hashwrite(f, header, hdrlen);
-		hashwrite(f, DELTA(entry)->idx.oid.hash, hashsz);
+		hashwrite_try_encrypt(f, header, hdrlen);
+		hashwrite_try_encrypt(f, DELTA(entry)->idx.oid.hash, hashsz);
 		hdrlen += hashsz;
 	} else {
 		if (limit && hdrlen + datalen + hashsz >= limit) {
@@ -530,13 +530,13 @@ static unsigned long write_no_reuse_object(struct hashfile *f, struct object_ent
 			free(buf);
 			return 0;
 		}
-		hashwrite(f, header, hdrlen);
+		hashwrite_try_encrypt(f, header, hdrlen);
 	}
 	if (st) {
 		datalen = write_large_blob_data(st, f, &entry->idx.oid);
 		close_istream(st);
 	} else {
-		hashwrite(f, buf, datalen);
+		hashwrite_try_encrypt(f, buf, datalen);
 		free(buf);
 	}
 
@@ -602,8 +602,8 @@ static off_t write_reuse_object(struct hashfile *f, struct object_entry *entry,
 			unuse_pack(&w_curs);
 			return 0;
 		}
-		hashwrite(f, header, hdrlen);
-		hashwrite(f, dheader + pos, sizeof(dheader) - pos);
+		hashwrite_try_encrypt(f, header, hdrlen);
+		hashwrite_try_encrypt(f, dheader + pos, sizeof(dheader) - pos);
 		hdrlen += sizeof(dheader) - pos;
 		reused_delta++;
 	} else if (type == OBJ_REF_DELTA) {
@@ -611,8 +611,8 @@ static off_t write_reuse_object(struct hashfile *f, struct object_entry *entry,
 			unuse_pack(&w_curs);
 			return 0;
 		}
-		hashwrite(f, header, hdrlen);
-		hashwrite(f, DELTA(entry)->idx.oid.hash, hashsz);
+		hashwrite_try_encrypt(f, header, hdrlen);
+		hashwrite_try_encrypt(f, DELTA(entry)->idx.oid.hash, hashsz);
 		hdrlen += hashsz;
 		reused_delta++;
 	} else {
@@ -620,7 +620,7 @@ static off_t write_reuse_object(struct hashfile *f, struct object_entry *entry,
 			unuse_pack(&w_curs);
 			return 0;
 		}
-		hashwrite(f, header, hdrlen);
+		hashwrite_try_encrypt(f, header, hdrlen);
 	}
 	copy_pack_data(f, p, &w_curs, offset, datalen);
 	unuse_pack(&w_curs);
@@ -1041,8 +1041,8 @@ static void write_reused_pack_one(size_t pos, struct hashfile *out,
 
 			len = encode_in_pack_object_header(header, sizeof(header),
 							   OBJ_REF_DELTA, size);
-			hashwrite(out, header, len);
-			hashwrite(out, base_oid.hash, the_hash_algo->rawsz);
+			hashwrite_try_encrypt(out, header, len);
+			hashwrite_try_encrypt(out, base_oid.hash, the_hash_algo->rawsz);
 			copy_pack_data(out, reuse_packfile, w_curs, cur, next - cur);
 			return;
 		}
@@ -1065,8 +1065,8 @@ static void write_reused_pack_one(size_t pos, struct hashfile *out,
 
 			ofs_len = sizeof(ofs_header) - i;
 
-			hashwrite(out, header, len);
-			hashwrite(out, ofs_header + sizeof(ofs_header) - ofs_len, ofs_len);
+			hashwrite_try_encrypt(out, header, len);
+			hashwrite_try_encrypt(out, ofs_header + sizeof(ofs_header) - ofs_len, ofs_len);
 			copy_pack_data(out, reuse_packfile, w_curs, cur, next - cur);
 			return;
 		}
@@ -1181,7 +1181,11 @@ static void write_pack_file(void)
 		else
 			f = create_tmp_packfile(&pack_tmp_name);
 
-		offset = write_pack_header(f, nr_remaining);
+		if (agit_crypto_enabled) {
+			f->cryptor = xmalloc(sizeof(struct git_cryptor));
+			git_encryptor_init_for_packfile(f->cryptor);
+		}
+		offset = write_pack_header_try_encrypt(f, nr_remaining);
 
 		if (reuse_packfile) {
 			assert(pack_to_stdout);
diff --git a/bulk-checkin.c b/bulk-checkin.c
index 6d6c37171c..a0e19bc965 100644
--- a/bulk-checkin.c
+++ b/bulk-checkin.c
@@ -198,8 +198,10 @@ static void prepare_to_stream(struct bulk_checkin_state *state,
 	state->f = create_tmp_packfile(&state->pack_tmp_name);
 	reset_pack_idx_option(&state->pack_idx_opts);
 
-	/* Pretend we are going to write only one object */
-	state->offset = write_pack_header(state->f, 1);
+	/* Pretend we are going to write only one object, and do not
+	 * encrypt this one-object packfile which is used to hold very
+	 * large blob object. */
+	state->offset = write_pack_header_no_encrypt(state->f, 1);
 	if (!state->offset)
 		die_errno("unable to write pack header");
 }
diff --git a/csum-file.c b/csum-file.c
index 59ef3398ca..36fb2c4c2b 100644
--- a/csum-file.c
+++ b/csum-file.c
@@ -8,6 +8,7 @@
  * able to verify hasn't been messed with afterwards.
  */
 #include "cache.h"
+#include "crypto.h"
 #include "progress.h"
 #include "csum-file.h"
 
@@ -88,43 +89,74 @@ int finalize_hashfile(struct hashfile *f, unsigned char *result,
 		if (close(f->check_fd))
 			die_errno("%s: sha1 file error on close", f->name);
 	}
+	if (!(flags & CSUM_CRYPTOR_NO_FREE))
+		free(f->cryptor);
 	free_hashfile(f);
 	return fd;
 }
 
-void hashwrite(struct hashfile *f, const void *buf, unsigned int count)
+static void do_hashwrite(struct hashfile *f, const void *buf, unsigned int count, int do_encrypt)
 {
+	unsigned int total = count;
+
+	if (do_encrypt && f->cryptor)
+		f->cryptor->byte_counter = f->encrypt_offset;
+
 	while (count) {
+		unsigned offset = f->offset;
 		unsigned left = f->buffer_len - f->offset;
 		unsigned nr = count > left ? left : count;
+		const void *data;
 
-		if (f->do_crc)
-			f->crc32 = crc32(f->crc32, buf, nr);
-
+		/* iff offset == 0, and left = nr = sizeof(f->buffer) */
 		if (nr == f->buffer_len) {
-			/*
-			 * Flush a full batch worth of data directly
-			 * from the input, skipping the memcpy() to
-			 * the hashfile's buffer. In this block,
-			 * f->offset is necessarily zero.
-			 */
-			the_hash_algo->update_fn(&f->ctx, buf, nr);
-			flush(f, buf, nr);
+			if (do_encrypt && f->cryptor) {
+				/* 'buf' maybe a mmap for reused packfile, so
+				 * copy * 'buf' to 'f->buffer' for encrypt.
+				 */
+				f->cryptor->encrypt(f->cryptor, buf, f->buffer, nr);
+				data = f->buffer;
+			} else {
+				/* process full buffer directly without copy */
+				data = buf;
+			}
 		} else {
-			/*
-			 * Copy to the hashfile's buffer, flushing only
-			 * if it became full.
-			 */
-			memcpy(f->buffer + f->offset, buf, nr);
-			f->offset += nr;
-			left -= nr;
-			if (!left)
-				hashflush(f);
+			if (do_encrypt && f->cryptor) {
+				f->cryptor->encrypt(f->cryptor, buf, f->buffer + offset, nr);
+			} else {
+				memcpy(f->buffer + offset, buf, nr);
+			}
+			data = f->buffer;
 		}
 
+		/* Do crc on encrypted data. */
+		if (f->do_crc)
+			f->crc32 = crc32(f->crc32, (unsigned char *)data + offset, nr);
+
 		count -= nr;
-		buf = (char *) buf + nr;
+		offset += nr;
+		buf = (char *)buf + nr;
+		left -= nr;
+		if (!left) {
+			/* Update checksum using encrypted data. */
+			the_hash_algo->update_fn(&f->ctx, data, offset);
+			flush(f, data, offset);
+			offset = 0;
+		}
+		f->offset = offset;
 	}
+	/* No matter do_encrypt or not, set encrypt_offset. */
+	f->encrypt_offset += total;
+}
+
+void hashwrite(struct hashfile *f, const void *buf, unsigned int count)
+{
+	do_hashwrite(f, buf, count, 0);
+}
+
+void hashwrite_try_encrypt(struct hashfile *f, const void *buf, unsigned int count)
+{
+	do_hashwrite(f, buf, count, 1);
 }
 
 struct hashfile *hashfd_check(const char *name)
@@ -153,6 +185,8 @@ static struct hashfile *hashfd_internal(int fd, const char *name,
 	f->tp = tp;
 	f->name = name;
 	f->do_crc = 0;
+	f->encrypt_offset = 0;
+	f->cryptor = NULL;
 	the_hash_algo->init_fn(&f->ctx);
 
 	f->buffer_len = buffer_len;
diff --git a/csum-file.h b/csum-file.h
index 0d29f528fb..7d4f9048b4 100644
--- a/csum-file.h
+++ b/csum-file.h
@@ -3,6 +3,7 @@
 
 #include "cache.h"
 #include "hash.h"
+#include "crypto.h"
 
 struct progress;
 
@@ -20,6 +21,9 @@ struct hashfile {
 	size_t buffer_len;
 	unsigned char *buffer;
 	unsigned char *check_buffer;
+	/* encryptor */
+	off_t encrypt_offset;
+	git_cryptor *cryptor;
 };
 
 /* Checkpoint */
@@ -35,12 +39,14 @@ int hashfile_truncate(struct hashfile *, struct hashfile_checkpoint *);
 #define CSUM_CLOSE		1
 #define CSUM_FSYNC		2
 #define CSUM_HASH_IN_STREAM	4
+#define CSUM_CRYPTOR_NO_FREE	8
 
 struct hashfile *hashfd(int fd, const char *name);
 struct hashfile *hashfd_check(const char *name);
 struct hashfile *hashfd_throughput(int fd, const char *name, struct progress *tp);
 int finalize_hashfile(struct hashfile *, unsigned char *, enum fsync_component, unsigned int);
 void hashwrite(struct hashfile *, const void *, unsigned int);
+void hashwrite_try_encrypt(struct hashfile *, const void *, unsigned int);
 void hashflush(struct hashfile *f);
 void crc32_begin(struct hashfile *);
 uint32_t crc32_end(struct hashfile *);
diff --git a/object-file.c b/object-file.c
index d2b29081ca..269a519a68 100644
--- a/object-file.c
+++ b/object-file.c
@@ -2385,6 +2385,12 @@ int index_path(struct index_state *istate, struct object_id *oid,
 	return rc;
 }
 
+/* read_pack_header is used by "fetch-pack" and "receive-pack" to quick validate
+ * packfile before passing the whole packfile to "unpack-objects" or "index-pack".
+ * After consuming the header by this function, will pass the consumed header
+ * information to "unpack-objects" or "index-pack" by additional option
+ * "--pack_header=xxx".
+ */
 int read_pack_header(int fd, struct pack_header *header)
 {
 	if (read_in_full(fd, header, sizeof(*header)) != sizeof(*header))
diff --git a/pack-write.c b/pack-write.c
index 51812cb129..65c67fa805 100644
--- a/pack-write.c
+++ b/pack-write.c
@@ -288,15 +288,37 @@ const char *write_rev_file_order(const char *rev_name,
 	return rev_name;
 }
 
-off_t write_pack_header(struct hashfile *f, uint32_t nr_entries)
+static off_t write_pack_header(struct hashfile *f, uint32_t nr_entries, int try_encrypt)
 {
-	struct pack_header hdr;
+	union extend_pack_header h;
+
+	h.hdr.hdr_signature = htonl(PACK_SIGNATURE);
+	h.hdr.hdr_entries = htonl(nr_entries);
+	if (f->cryptor && try_encrypt) {
+		h.hdr.hdr_version = htonl(git_encryptor_get_host_pack_version(
+			f->cryptor, h.ehdr.nonce));
+		if (crypto_pack_has_longer_nonce_for_algo(
+			    f->cryptor->algorithm)) {
+			hashwrite(f, &h.ehdr, sizeof(h.ehdr));
+			return sizeof(struct pack_header_with_nonce);
+		} else {
+			hashwrite(f, &h.hdr, sizeof(h.hdr));
+			return sizeof(struct pack_header);
+		}
+	}
+	h.hdr.hdr_version = htonl(PACK_VERSION);
+	hashwrite(f, &h.hdr, sizeof(h.hdr));
+	return sizeof(struct pack_header);
+}
 
-	hdr.hdr_signature = htonl(PACK_SIGNATURE);
-	hdr.hdr_version = htonl(PACK_VERSION);
-	hdr.hdr_entries = htonl(nr_entries);
-	hashwrite(f, &hdr, sizeof(hdr));
-	return sizeof(hdr);
+off_t write_pack_header_no_encrypt(struct hashfile *f, uint32_t nr_entries)
+{
+	return write_pack_header(f, nr_entries, 0);
+}
+
+off_t write_pack_header_try_encrypt(struct hashfile *f, uint32_t nr_entries)
+{
+	return write_pack_header(f, nr_entries, 1);
 }
 
 /*
diff --git a/pack.h b/pack.h
index b22bfc4a18..8b743a2322 100644
--- a/pack.h
+++ b/pack.h
@@ -18,6 +18,19 @@ struct pack_header {
 	uint32_t hdr_entries;
 };
 
+struct pack_header_with_nonce {
+	uint32_t hdr_signature;
+	uint32_t hdr_version;
+	uint32_t hdr_entries;
+
+	unsigned char nonce[NONCE_LEN];
+};
+
+union extend_pack_header {
+	struct pack_header hdr;
+	struct pack_header_with_nonce ehdr;
+};
+
 /*
  * The first four bytes of index formats later than version 1 should
  * start with this signature, as all older git binaries would find this
@@ -85,7 +98,8 @@ const char *write_idx_file(const char *index_name, struct pack_idx_entry **objec
 int check_pack_crc(struct packed_git *p, struct pack_window **w_curs, off_t offset, off_t len, unsigned int nr);
 int verify_pack_index(struct packed_git *);
 int verify_pack(struct repository *, struct packed_git *, verify_fn fn, struct progress *, uint32_t);
-off_t write_pack_header(struct hashfile *f, uint32_t);
+off_t write_pack_header_no_encrypt(struct hashfile *f, uint32_t);
+off_t write_pack_header_try_encrypt(struct hashfile *f, uint32_t);
 void fixup_pack_header_footer(int, unsigned char *, const char *, uint32_t, unsigned char *, off_t);
 char *index_pack_lockfile(int fd, int *is_well_formed);
 
diff --git a/packfile.c b/packfile.c
index 835b2d2716..d5bc4632b9 100644
--- a/packfile.c
+++ b/packfile.c
@@ -594,6 +594,13 @@ static int open_packed_git(struct packed_git *p)
 	return -1;
 }
 
+int open_packed_git_once(struct packed_git *p)
+{
+	if (p->pack_fd == -1)
+		return open_packed_git(p);
+	return 0;
+}
+
 static int in_window(struct pack_window *win, off_t offset)
 {
 	/* We must promise at least one full hash after the
diff --git a/packfile.h b/packfile.h
index a3f6723857..12b40f7749 100644
--- a/packfile.h
+++ b/packfile.h
@@ -72,6 +72,8 @@ struct packed_git *find_sha1_pack(const unsigned char *sha1,
 
 void pack_report(void);
 
+int open_packed_git_once(struct packed_git *p);
+
 /*
  * mmap the index file for the specified packfile (if it is not
  * already mmapped).  Return 0 on success.
diff --git a/t/t0940-crypto-repository.sh b/t/t0940-crypto-repository.sh
index dce537ac0e..5573b2cc99 100755
--- a/t/t0940-crypto-repository.sh
+++ b/t/t0940-crypto-repository.sh
@@ -42,6 +42,22 @@ show_lo_header () {
 	test_copy_bytes 20
 }
 
+show_pack_header () {
+	case ${GIT_TEST_CRYPTO_ALGORITHM_TYPE} in
+	1 | 2)
+		hdr_size=24
+		;;
+	64 | 65)
+		hdr_size=12
+		;;
+	*)
+		echo >&2 "ERROR: unknown algorithm"
+		return 1
+		;;
+	esac &&
+	test_copy_bytes $hdr_size
+}
+
 # Some absolute path tests should be skipped on Windows due to path mangling
 # on POSIX-style absolute paths
 case $(uname -s) in
diff --git a/t/t0940/test-0020-read-write-packfile.sh b/t/t0940/test-0020-read-write-packfile.sh
new file mode 100644
index 0000000000..0652124d63
--- /dev/null
+++ b/t/t0940/test-0020-read-write-packfile.sh
@@ -0,0 +1,94 @@
+#!/bin/sh
+
+# Test read/write encrypted packfile
+
+test_expect_success 'setup' '
+	git config agit.crypto.enabled 1 &&
+	git config agit.crypto.secret c2VjcmV0LXRva2VuMTIzNA== &&
+	git config agit.crypto.nonce random_nonce
+'
+
+test_expect_success 'create commits' '
+	test_commit A &&
+	test_commit B
+'
+
+test_expect_success 'check header of unencrypt packfile' '
+	git -c agit.crypto.enabled=0 \
+		pack-objects --revs --stdout >packfile.0 <<-\EOF &&
+	main
+	EOF
+	test_copy_bytes 12 <packfile.0 | test-tool agit-od >actual &&
+	cat >expect <<-\EOF &&
+	0000000 50 41 43 4b 00 00 00 02 00 00 00 06                | PACK........     |
+	EOF
+	test_cmp expect actual
+'
+
+# algorithm: benchmark
+cat >expect-hdr-1 <<-EOF &&
+0000000 50 41 43 4b 81 00 00 02 00 00 00 06 72 61 6e 64    | PACK........rand |
+0000016 6f 6d 5f 6e 6f 6e 63 65                            | om_nonce         |
+EOF
+
+# algorithm: aes
+cat >expect-hdr-2 <<-EOF &&
+0000000 50 41 43 4b 82 00 00 02 00 00 00 06 72 61 6e 64    | PACK........rand |
+0000016 6f 6d 5f 6e 6f 6e 63 65                            | om_nonce         |
+EOF
+
+cat >expect-hdr-64 <<-EOF &&
+0000000 50 41 43 4b c0 61 72 02 00 00 00 06                | PACK.ar.....     |
+EOF
+
+cat >expect-hdr-65 <<-EOF &&
+0000000 50 41 43 4b c1 61 72 02 00 00 00 06                | PACK.ar.....     |
+EOF
+
+test_expect_success 'check header of encrypt packfile' '
+	git pack-objects --revs --stdout >packfile.algo-${GIT_TEST_CRYPTO_ALGORITHM_TYPE} <<-\EOF &&
+	main
+	EOF
+	show_pack_header <packfile.algo-${GIT_TEST_CRYPTO_ALGORITHM_TYPE} |
+		test-tool agit-od >actual &&
+	test_cmp expect-hdr-${GIT_TEST_CRYPTO_ALGORITHM_TYPE} actual
+'
+
+test_expect_success 'unpack-objects on unencrypted packfile' '
+	test_create_repo unpack.0 &&
+	git -C unpack.0 unpack-objects <packfile.0
+'
+
+test_expect_success 'index-pack on unencrypted packfile' '
+	test_create_repo index-pack.0 &&
+	pack=$(git -C index-pack.0 index-pack --stdin <packfile.0) &&
+	pack=${pack#pack?} &&
+	test -f "index-pack.0/.git/objects/pack/pack-$pack.pack"
+'
+
+test_expect_success 'verify-pack on uncrypted packfile' '
+	git -C index-pack.0 verify-pack .git/objects/pack/pack-$pack.pack
+'
+
+test_expect_failure 'unpack-objects on encrypted packfile' '
+	test_create_repo unpack.1 &&
+	git -C unpack.1 config agit.crypto.enabled 1 &&
+	git -C unpack.1 config agit.crypto.secret c2VjcmV0LXRva2VuMTIzNA== &&
+	git -C unpack.1 config agit.crypto.nonce random_nonce &&
+	git -C unpack.1 unpack-objects <packfile.algo-${GIT_TEST_CRYPTO_ALGORITHM_TYPE}
+'
+
+test_expect_failure 'index-pack on encrypted packfile' '
+	test_create_repo index-pack.1 &&
+	git -C index-pack.1 config agit.crypto.enabled 1 &&
+	git -C index-pack.1 config agit.crypto.secret c2VjcmV0LXRva2VuMTIzNA== &&
+	git -C index-pack.1 config agit.crypto.nonce random_nonce &&
+	pack=$(git -C index-pack.1 index-pack \
+		--stdin <packfile.algo-${GIT_TEST_CRYPTO_ALGORITHM_TYPE}) &&
+	pack=${pack#pack?} &&
+	test -f index-pack.1/.git/objects/pack/pack-$pack.pack
+'
+
+test_expect_failure 'verify-pack on encrypted packfile' '
+	git -C index-pack.1 verify-pack .git/objects/pack/pack-$pack.pack
+'
diff --git a/t/t0940/test-0021-fast-export-and-import.sh b/t/t0940/test-0021-fast-export-and-import.sh
new file mode 100644
index 0000000000..2a9c8d821f
--- /dev/null
+++ b/t/t0940/test-0021-fast-export-and-import.sh
@@ -0,0 +1,146 @@
+#!/bin/sh
+
+# Test crypto on "git-fast-export-and-import"
+
+test_expect_success 'create normal commits' '
+	test_commit A &&
+	test_commit B
+'
+
+test_expect_success 'enable encrypt settings' '
+	git config agit.crypto.enabled 1 &&
+	git config agit.crypto.secret c2VjcmV0LXRva2VuMTIzNA== &&
+	git config agit.crypto.nonce random_nonce
+'
+
+test_expect_success 'create encrypted commits' '
+	test_commit C &&
+	test_commit D
+'
+
+test_expect_success 'fast-export' '
+	git fast-export --all --full-tree >export.data
+'
+
+test_expect_success 'fast-import to normal repo' '
+	create_bare_repo normal.git &&
+	(
+		cd normal.git &&
+		git fast-import <../export.data &&
+		git fsck &&
+		git log --pretty="%s" main >actual &&
+		cat >expect <<-EOF &&
+		D
+		C
+		B
+		A
+		EOF
+		test_cmp expect actual
+	)
+'
+
+test_expect_success 'fast-import encrypt repo' '
+	create_bare_repo encrypt-loose.git &&
+	(
+		cd encrypt-loose.git &&
+
+		# encrypt settings
+		git config agit.crypto.enabled 1 &&
+		git config agit.crypto.secret c2VjcmV0LXRva2VuMTIzNA== &&
+		git config agit.crypto.nonce random_nonce &&
+
+		git fast-import <../export.data &&
+		git fsck &&
+		git log --pretty="%s" main >actual &&
+		cat >expect <<-EOF &&
+		D
+		C
+		B
+		A
+		EOF
+		test_cmp expect actual
+	)
+'
+
+cat >expect_1 <<-EOF &&
+0000000 45 4e 43 00 81 00 00 00 72 61 6e 64 6f 6d 5f 6e    | ENC.....random_n |
+0000016 6f 6e 63 65                                        | once             |
+EOF
+
+cat >expect_2 <<-EOF &&
+0000000 45 4e 43 00 82 00 00 00 72 61 6e 64 6f 6d 5f 6e    | ENC.....random_n |
+0000016 6f 6e 63 65                                        | once             |
+EOF
+
+cat >expect_64 <<-EOF
+0000000 45 4e 43 00 c0 00 00 00 72 61 6e 64 6f 6d 5f 6e    | ENC.....random_n |
+0000016 6f 6e 63 65                                        | once             |
+EOF
+
+cat >expect_65 <<-EOF
+0000000 45 4e 43 00 c1 00 00 00 72 61 6e 64 6f 6d 5f 6e    | ENC.....random_n |
+0000016 6f 6e 63 65                                        | once             |
+EOF
+
+test_expect_success 'after import, loose object is encrypted' '
+	oid=$(git -C encrypt-loose.git rev-parse main:A.t) &&
+	show_lo_header <encrypt-loose.git/objects/${oid%${oid#??}}/${oid#??} |
+		test-tool agit-od >actual &&
+	test_cmp expect_${GIT_TEST_CRYPTO_ALGORITHM_TYPE} actual
+'
+
+test_expect_success 'git fsck for encrypted loose objects' '
+	git -C encrypt-loose.git fsck
+'
+
+test_expect_success 'fast-import to encrypt packfile' '
+	create_bare_repo encrypt-pack.git &&
+	(
+		cd encrypt-pack.git &&
+
+		# encrypt settings
+		git config agit.crypto.enabled 1 &&
+		git config agit.crypto.secret c2VjcmV0LXRva2VuMTIzNA== &&
+		git config agit.crypto.nonce random_nonce &&
+		git config fastimport.unpacklimit 1 &&
+
+		git fast-import <../export.data &&
+		git fsck &&
+		git log --pretty="%s" main >actual &&
+		cat >expect <<-EOF &&
+		D
+		C
+		B
+		A
+		EOF
+		test_cmp expect actual
+	)
+'
+
+cat >expect_1 <<-EOF &&
+0000000 50 41 43 4b 81 00 00 02 00 00 00 0c 72 61 6e 64    | PACK........rand |
+0000016 6f 6d 5f 6e 6f 6e 63 65                            | om_nonce         |
+EOF
+
+cat >expect_2 <<-EOF &&
+0000000 50 41 43 4b 82 00 00 02 00 00 00 0c 72 61 6e 64    | PACK........rand |
+0000016 6f 6d 5f 6e 6f 6e 63 65                            | om_nonce         |
+EOF
+
+cat >expect_64 <<-EOF &&
+0000000 50 41 43 4b c0 61 72 02 00 00 00 0c                | PACK.ar.....     |
+EOF
+
+cat >expect_65 <<-EOF &&
+0000000 50 41 43 4b c1 61 72 02 00 00 00 0c                | PACK.ar.....     |
+EOF
+
+test_expect_failure 'after import, packfile is encrypted' '
+	show_pack_header <encrypt-pack.git/objects/pack/pack-*.pack |
+		test-tool agit-od >actual &&
+	test_cmp expect_${GIT_TEST_CRYPTO_ALGORITHM_TYPE} actual
+'
+
+test_expect_success 'git fsck for encrypted packfile' '
+	git -C encrypt-pack.git fsck
+'
-- 
patchwork
