From d60335d5756b972e75a4e1dd65a03e1fa9da8fb5 Mon Sep 17 00:00:00 2001
From: Jiang Xin <zhiyou.jx@alibaba-inc.com>
Date: Thu, 30 Jun 2022 16:47:10 +0800
Subject: [PATCH 65/65] fetch-to-packed-refs: only packs fetched refs

For those unchanged loose refs, do not write them to the "packed-refs"
file.  Only write the new fetched references to the "packed-refs" file.

Signed-off-by: Jiang Xin <zhiyou.jx@alibaba-inc.com>
---
 refs/files-backend.c                       |  24 +-
 t/t5593-fetch-write-packed-refs.sh         | 654 ++++++++++++++++++++-
 t/t5594-remote-update-write-packed-refs.sh |  21 +-
 3 files changed, 651 insertions(+), 48 deletions(-)

diff --git a/refs/files-backend.c b/refs/files-backend.c
index 19cb525c12..9a7d536eca 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
@@ -1336,27 +1336,9 @@ static int files_direct_to_packed_refs(struct ref_store *ref_store,
 	while ((ok = ref_iterator_advance(iter)) == ITER_OK) {
 		struct ref_to_prune *n;
 
-		/* duplicate ref from loose items */
-		if (!ref_contains(&affected_refnames, iter->refname)) {
-			/*
-			 * If the loose reference can be packed, add an entry
-			 * in the packed ref cache. If the reference should be
-			 * pruned, also add it to refs_to_prune.
-			 */
-			if (!should_pack_ref(iter->refname, iter->oid,
-					     iter->flags, PACK_REFS_ALL))
-				continue;
-
-			/*
-			 * Add a reference creation for this reference to the
-			 * packed-refs transaction:
-			 */
-			if (ref_transaction_update(
-				    packed_transaction, iter->refname,
-				    iter->oid, NULL, REF_NO_DEREF, NULL, err))
-				die("failure preparing to create packed reference %s: %s",
-				    iter->refname, err->buf);
-		}
+		/* do not pack loose refs not in transaction */
+		if (!ref_contains(&affected_refnames, iter->refname))
+			continue;
 
 		/* Schedule the loose reference for pruning if requested. */
 		FLEX_ALLOC_STR(n, name, iter->refname);
diff --git a/t/t5593-fetch-write-packed-refs.sh b/t/t5593-fetch-write-packed-refs.sh
index f0c273676a..164478e2a9 100755
--- a/t/t5593-fetch-write-packed-refs.sh
+++ b/t/t5593-fetch-write-packed-refs.sh
@@ -138,10 +138,6 @@ make_user_friendly_and_stable_output () {
 		-e "s/$ZERO_OID/<ZERO-OID>/g"
 }
 
-assert_no_loose () {
-	test_loose_refs_count dest.git 0
-}
-
 test_loose_refs_count () {
 	DIR="$1/refs" &&
 	EXPECTED_COUNT="$2" &&
@@ -150,28 +146,68 @@ test_loose_refs_count () {
 	test_line_count = $EXPECTED_COUNT actual
 }
 
-test_expect_success setup '
+# workdir:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+test_expect_success "setup worktree" '
+	# create commits in the main branch
 	test_commit_setvar A "Commit-A" README.txt &&
-	git branch branch-A &&
+	git branch topic/A &&
 	git tag tag-A &&
 	test_commit_setvar B "Commit-B" README.txt &&
-	git branch branch-B &&
+	git branch topic/B &&
 	git tag tag-B &&
 	test_commit_setvar C "Commit-C" README.txt &&
-	git branch branch-C &&
+	git branch topic/C &&
 	git tag tag-C &&
-	git init --bare dest.git
+	test_commit_setvar D "Commit-D" README.txt &&
+	git branch topic/D &&
+	git tag tag-D &&
+	# reset main branch to commit-C
+	git reset --hard HEAD~
 '
 
-test_expect_success 'test fetch into loose objects' '
-	git -C dest.git fetch "file://$TRASH_DIRECTORY" "+refs/*:refs/*" &&
-	! test -e dest.git/packed-refs &&
+# workdir:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+# base.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (A, tag-A)
+#     topic/C (C, tag-C)
+#
+test_expect_success "prepare base.git" '
+	git init --bare base.git &&
+	git push base.git main topic/A topic/B topic/C tag-A tag-B tag-C &&
+	git -C base.git update-ref refs/heads/topic/B $A &&
+	test_loose_refs_count base.git 7
+'
+
+test_expect_success 'base -> dest: fetch into loose refs' '
+	git init --bare dest.git &&
+	test_when_finished "rm -rf dest.git" &&
+
+	git -C dest.git fetch ../base.git "+refs/*:refs/*" &&
+
+	test_path_is_missing dest.git/packed-refs &&
+	test_loose_refs_count dest.git 7 &&
 	cat >expect <<-EOF &&
 	<COMMIT-C> HEAD
-	<COMMIT-A> refs/heads/branch-A
-	<COMMIT-B> refs/heads/branch-B
-	<COMMIT-C> refs/heads/branch-C
 	<COMMIT-C> refs/heads/main
+	<COMMIT-A> refs/heads/topic/A
+	<COMMIT-A> refs/heads/topic/B
+	<COMMIT-C> refs/heads/topic/C
 	<COMMIT-A> refs/tags/tag-A
 	<COMMIT-B> refs/tags/tag-B
 	<COMMIT-C> refs/tags/tag-C
@@ -181,27 +217,595 @@ test_expect_success 'test fetch into loose objects' '
 	test_cmp expect actual
 '
 
-test_expect_success 'delete branch-B and change branch-C' '
-	git branch -D branch-B &&
-	test_commit_setvar D "Commit-D" README.txt &&
-	git branch -M branch-C &&
-	echo "$B refs/heads/branch-A" >dest.git/packed-refs
+test_expect_success 'base -> dest: fetch to packed-refs (via args)' '
+	git init --bare dest.git &&
+	test_when_finished "rm -rf dest.git" &&
+
+	git -C dest.git \
+		fetch --write-packed-refs ../base.git "+refs/*:refs/*" &&
+
+	test_loose_refs_count dest.git 0 &&
+	test_path_is_file dest.git/packed-refs &&
+	cat >expect <<-EOF &&
+	<COMMIT-C> HEAD
+	<COMMIT-C> refs/heads/main
+	<COMMIT-A> refs/heads/topic/A
+	<COMMIT-A> refs/heads/topic/B
+	<COMMIT-C> refs/heads/topic/C
+	<COMMIT-A> refs/tags/tag-A
+	<COMMIT-B> refs/tags/tag-B
+	<COMMIT-C> refs/tags/tag-C
+	EOF
+	git -C dest.git show-ref --head |
+		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual
 '
 
-test_expect_success 'test fetch with "fetch.writePackedRefs"' '
+test_expect_success 'base -> dest: fetch to packed-refs (via git config)' '
+	git init --bare dest.git &&
+	test_when_finished "rm -rf dest.git" &&
+
 	git -c fetch.writePackedRefs=true -C dest.git \
-		fetch -p "file://$TRASH_DIRECTORY" "+refs/*:refs/*" &&
-	assert_no_loose &&
+		fetch ../base.git "+refs/*:refs/*" &&
+
+	test_loose_refs_count dest.git 0 &&
+	test_path_is_file dest.git/packed-refs &&
+	cat >expect <<-EOF &&
+	<COMMIT-C> HEAD
+	<COMMIT-C> refs/heads/main
+	<COMMIT-A> refs/heads/topic/A
+	<COMMIT-A> refs/heads/topic/B
+	<COMMIT-C> refs/heads/topic/C
+	<COMMIT-A> refs/tags/tag-A
+	<COMMIT-B> refs/tags/tag-B
+	<COMMIT-C> refs/tags/tag-C
+	EOF
+	git -C dest.git show-ref --head |
+		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual
+'
+
+# workdir:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+# base.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (A, tag-A)
+#     topic/C (C, tag-C)
+#
+# source.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (A, tag-A)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+test_expect_success 'incremental fetch: new references' '
+	git clone --mirror base.git source.git &&
+	git push source.git topic/D tag-D &&
+	test_when_finished "rm -rf source.git" &&
+
+	git init --bare dest.git &&
+	test_when_finished "rm -rf dest.git" &&
+
+	git -C dest.git fetch ../base.git "+refs/*:refs/*" &&
+	test_path_is_missing dest.git/packed-refs &&
+	test_loose_refs_count dest.git 7 &&
+
+	git -C dest.git fetch ../source.git "+refs/*:refs/*" &&
+	test_path_is_missing dest.git/packed-refs &&
+
+	test_loose_refs_count dest.git 9 &&
+	cat >expect <<-EOF &&
+	<COMMIT-C> HEAD
+	<COMMIT-C> refs/heads/main
+	<COMMIT-A> refs/heads/topic/A
+	<COMMIT-A> refs/heads/topic/B
+	<COMMIT-C> refs/heads/topic/C
+	<COMMIT-D> refs/heads/topic/D
+	<COMMIT-A> refs/tags/tag-A
+	<COMMIT-B> refs/tags/tag-B
+	<COMMIT-C> refs/tags/tag-C
+	<COMMIT-D> refs/tags/tag-D
+	EOF
+	git -C dest.git show-ref --head |
+		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual
+'
+
+# workdir:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+# base.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (A, tag-A)
+#     topic/C (C, tag-C)
+#
+# source.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (A, tag-A)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+test_expect_success 'incremental fetch: new references (fetch to packed-refs)' '
+	git clone --mirror base.git source.git &&
+	git push source.git topic/D tag-D &&
+	test_when_finished "rm -rf source.git" &&
+
+	git init --bare dest.git &&
+	test_when_finished "rm -rf dest.git" &&
+
+	git -C dest.git fetch ../base.git "+refs/*:refs/*" &&
+	test_path_is_missing dest.git/packed-refs &&
+	test_loose_refs_count dest.git 7 &&
+
+	git -c fetch.writepackedrefs=true -C dest.git \
+		fetch ../source.git "+refs/*:refs/*" &&
+	cat >expect <<-EOF &&
+	<COMMIT-C> HEAD
+	<COMMIT-C> refs/heads/main
+	<COMMIT-A> refs/heads/topic/A
+	<COMMIT-A> refs/heads/topic/B
+	<COMMIT-C> refs/heads/topic/C
+	<COMMIT-D> refs/heads/topic/D
+	<COMMIT-A> refs/tags/tag-A
+	<COMMIT-B> refs/tags/tag-B
+	<COMMIT-C> refs/tags/tag-C
+	<COMMIT-D> refs/tags/tag-D
+	EOF
+	git -C dest.git show-ref --head |
+		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual &&
+
+	test_path_is_file dest.git/packed-refs &&
+	cat dest.git/packed-refs |
+		make_user_friendly_and_stable_output >actual &&
 	cat >expect <<-EOF &&
 	# pack-refs with: peeled fully-peeled sorted
-	<COMMIT-A> refs/heads/branch-A
-	<COMMIT-D> refs/heads/branch-C
+	<COMMIT-D> refs/heads/topic/D
+	<COMMIT-D> refs/tags/tag-D
+	EOF
+	test_cmp expect actual &&
+	test_loose_refs_count dest.git 7
+'
+
+# workdir:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+# base.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (A, tag-A)
+#     topic/C (C, tag-C)
+#
+# source.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#
+test_expect_success 'incremental fetch: update references' '
+	git clone --mirror base.git source.git &&
+	git -C source.git update-ref refs/heads/topic/B $B &&
+	test_when_finished "rm -rf source.git" &&
+
+	git init --bare dest.git &&
+	test_when_finished "rm -rf dest.git" &&
+
+	git -C dest.git fetch ../base.git "+refs/*:refs/*" &&
+	test_path_is_missing dest.git/packed-refs &&
+	test_loose_refs_count dest.git 7 &&
+
+	git -C dest.git fetch ../source.git "+refs/*:refs/*" &&
+	test_path_is_missing dest.git/packed-refs &&
+
+	test_loose_refs_count dest.git 7 &&
+	cat >expect <<-EOF &&
+	<COMMIT-C> HEAD
+	<COMMIT-C> refs/heads/main
+	<COMMIT-A> refs/heads/topic/A
+	<COMMIT-B> refs/heads/topic/B
+	<COMMIT-C> refs/heads/topic/C
 	<COMMIT-A> refs/tags/tag-A
 	<COMMIT-B> refs/tags/tag-B
 	<COMMIT-C> refs/tags/tag-C
 	EOF
+	git -C dest.git show-ref --head |
+		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual
+'
+
+# workdir:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+# base.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (A, tag-A)
+#     topic/C (C, tag-C)
+#
+# source.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#
+test_expect_success 'incremental fetch: update references (fetch to packed-refs)' '
+	git clone --mirror base.git source.git &&
+	git -C source.git update-ref refs/heads/topic/B $B &&
+	test_when_finished "rm -rf source.git" &&
+
+	git init --bare dest.git &&
+	test_when_finished "rm -rf dest.git" &&
+
+	git -C dest.git fetch ../base.git "+refs/*:refs/*" &&
+	test_path_is_missing dest.git/packed-refs &&
+	test_loose_refs_count dest.git 7 &&
+
+	git -c fetch.writepackedrefs=true -C dest.git \
+		fetch ../source.git "+refs/*:refs/*" &&
+	cat >expect <<-EOF &&
+	<COMMIT-C> HEAD
+	<COMMIT-C> refs/heads/main
+	<COMMIT-A> refs/heads/topic/A
+	<COMMIT-B> refs/heads/topic/B
+	<COMMIT-C> refs/heads/topic/C
+	<COMMIT-A> refs/tags/tag-A
+	<COMMIT-B> refs/tags/tag-B
+	<COMMIT-C> refs/tags/tag-C
+	EOF
+	git -C dest.git show-ref --head |
+		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual &&
+
+	test_path_is_file dest.git/packed-refs &&
+	cat dest.git/packed-refs |
+		make_user_friendly_and_stable_output >actual &&
+	cat >expect <<-EOF &&
+	# pack-refs with: peeled fully-peeled sorted
+	<COMMIT-B> refs/heads/topic/B
+	EOF
+	test_cmp expect actual &&
+	test_loose_refs_count dest.git 6
+'
+
+# workdir:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+# base.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (A, tag-A)
+#     topic/C (C, tag-C)
+#
+# source.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/C (C, tag-C)
+#
+test_expect_success 'incremental fetch: remove references' '
+	git clone --mirror base.git source.git &&
+	git -C source.git update-ref -d refs/heads/topic/B &&
+	git -C source.git update-ref -d refs/tags/tag-B &&
+	test_when_finished "rm -rf source.git" &&
+
+	git init --bare dest.git &&
+	test_when_finished "rm -rf dest.git" &&
+
+	git -C dest.git fetch ../base.git "+refs/*:refs/*" &&
+	test_path_is_missing dest.git/packed-refs &&
+	test_loose_refs_count dest.git 7 &&
+
+	git -C dest.git fetch --prune ../source.git "+refs/*:refs/*" &&
+	test_path_is_file dest.git/packed-refs &&
+	cat >expect <<-EOF &&
+	# pack-refs with: peeled fully-peeled sorted 
+	EOF
+	test_cmp expect dest.git/packed-refs &&
+
+	test_loose_refs_count dest.git 5 &&
+	cat >expect <<-EOF &&
+	<COMMIT-C> HEAD
+	<COMMIT-C> refs/heads/main
+	<COMMIT-A> refs/heads/topic/A
+	<COMMIT-C> refs/heads/topic/C
+	<COMMIT-A> refs/tags/tag-A
+	<COMMIT-C> refs/tags/tag-C
+	EOF
+	git -C dest.git show-ref --head |
+		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual
+'
+
+# workdir:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+# base.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (A, tag-A)
+#     topic/C (C, tag-C)
+#
+# source.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/C (C, tag-C)
+#
+test_expect_success 'incremental fetch: remove references (fetch to packed-refs)' '
+	git clone --mirror base.git source.git &&
+	git -C source.git update-ref -d refs/heads/topic/B &&
+	git -C source.git update-ref -d refs/tags/tag-B &&
+	test_when_finished "rm -rf source.git" &&
+
+	git init --bare dest.git &&
+	test_when_finished "rm -rf dest.git" &&
+
+	git -C dest.git fetch ../base.git "+refs/*:refs/*" &&
+	test_path_is_missing dest.git/packed-refs &&
+	test_loose_refs_count dest.git 7 &&
+
+	git -c fetch.writepackedrefs=true -C dest.git \
+		fetch --prune ../source.git "+refs/*:refs/*" &&
+	test_path_is_file dest.git/packed-refs &&
+	cat >expect <<-EOF &&
+	# pack-refs with: peeled fully-peeled sorted 
+	EOF
+	test_cmp expect dest.git/packed-refs &&
+
+	test_loose_refs_count dest.git 5 &&
+	cat >expect <<-EOF &&
+	<COMMIT-C> HEAD
+	<COMMIT-C> refs/heads/main
+	<COMMIT-A> refs/heads/topic/A
+	<COMMIT-C> refs/heads/topic/C
+	<COMMIT-A> refs/tags/tag-A
+	<COMMIT-C> refs/tags/tag-C
+	EOF
+	git -C dest.git show-ref --head |
+		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual
+'
+
+# workdir:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+# base.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (A, tag-A)
+#     topic/C (C, tag-C)
+#
+# source.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-A)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+test_expect_success 'incremental fetch: variant updates' '
+	git clone --mirror base.git source.git &&
+	git -C source.git update-ref refs/heads/topic/B $B &&
+	git -C source.git update-ref -d refs/heads/topic/C &&
+	git -C source.git update-ref -d refs/tags/tag-C &&
+	git push source.git topic/D tag-D &&
+	test_when_finished "rm -rf source.git" &&
+
+	git init --bare dest.git &&
+	test_when_finished "rm -rf dest.git" &&
+
+	git -C dest.git fetch ../base.git "+refs/*:refs/*" &&
+	test_path_is_missing dest.git/packed-refs &&
+	test_loose_refs_count dest.git 7 &&
+
+	git -C dest.git fetch --prune ../source.git "+refs/*:refs/*" &&
+	test_path_is_file dest.git/packed-refs &&
+	cat >expect <<-EOF &&
+	# pack-refs with: peeled fully-peeled sorted 
+	EOF
+	test_cmp expect dest.git/packed-refs &&
+
+	test_loose_refs_count dest.git 7 &&
+	cat >expect <<-EOF &&
+	<COMMIT-C> HEAD
+	<COMMIT-C> refs/heads/main
+	<COMMIT-A> refs/heads/topic/A
+	<COMMIT-B> refs/heads/topic/B
+	<COMMIT-D> refs/heads/topic/D
+	<COMMIT-A> refs/tags/tag-A
+	<COMMIT-B> refs/tags/tag-B
+	<COMMIT-D> refs/tags/tag-D
+	EOF
+	git -C dest.git show-ref --head |
+		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual
+'
+
+# workdir:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+# base.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (A, tag-A)
+#     topic/C (C, tag-C)
+#
+# source.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-A)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+test_expect_success 'incremental fetch: variant updates (fetch to packed-refs)' '
+	git clone --mirror base.git source.git &&
+	git -C source.git update-ref refs/heads/topic/B $B &&
+	git -C source.git update-ref -d refs/heads/topic/C &&
+	git -C source.git update-ref -d refs/tags/tag-C &&
+	git push source.git topic/D tag-D &&
+	test_when_finished "rm -rf source.git" &&
+
+	git init --bare dest.git &&
+	test_when_finished "rm -rf dest.git" &&
+
+	git -C dest.git fetch ../base.git "+refs/*:refs/*" &&
+	test_path_is_missing dest.git/packed-refs &&
+	test_loose_refs_count dest.git 7 &&
+
+	git -c fetch.writepackedrefs=true -C dest.git \
+		fetch --prune ../source.git "+refs/*:refs/*" &&
+	test_path_is_file dest.git/packed-refs &&
+	cat >expect <<-EOF &&
+	# pack-refs with: peeled fully-peeled sorted
+	<COMMIT-B> refs/heads/topic/B
+	<COMMIT-D> refs/heads/topic/D
+	<COMMIT-D> refs/tags/tag-D
+	EOF
+	cat dest.git/packed-refs |
+		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual &&
+
+	test_loose_refs_count dest.git 4 &&
+	cat >expect <<-EOF &&
+	<COMMIT-C> HEAD
+	<COMMIT-C> refs/heads/main
+	<COMMIT-A> refs/heads/topic/A
+	<COMMIT-B> refs/heads/topic/B
+	<COMMIT-D> refs/heads/topic/D
+	<COMMIT-A> refs/tags/tag-A
+	<COMMIT-B> refs/tags/tag-B
+	<COMMIT-D> refs/tags/tag-D
+	EOF
+	git -C dest.git show-ref --head |
+		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual
+'
+
+# workdir:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+# base.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (A, tag-A)
+#     topic/C (C, tag-C)
+#
+# source.git:
+#
+#   * main (C)
+#     topic/A (A, tag-A)
+#     topic/B (B, tag-B)
+#     topic/C (C, tag-C)
+#     topic/D (D, tag-D)
+#
+test_expect_success 'incremental fetch: has old packed-refs (fetch to packed-refs)' '
+	git clone --mirror base.git source.git &&
+	git -C source.git update-ref refs/heads/topic/B $B &&
+	git -C source.git update-ref -d refs/heads/topic/C &&
+	git -C source.git update-ref -d refs/tags/tag-C &&
+	git push source.git topic/D tag-D &&
+	test_when_finished "rm -rf source.git" &&
+
+	git init --bare dest.git &&
+	test_when_finished "rm -rf dest.git" &&
+
+	git -C dest.git fetch ../base.git "+refs/*:refs/*" &&
+	test_path_is_missing dest.git/packed-refs &&
+	test_loose_refs_count dest.git 7 &&
+	echo "$B refs/heads/topic/A"  >dest.git/packed-refs &&
+	echo "$C refs/heads/topic/B" >>dest.git/packed-refs &&
+
+	git -c fetch.writepackedrefs=true -C dest.git \
+		fetch --prune ../source.git "+refs/*:refs/*" &&
+	test_path_is_file dest.git/packed-refs &&
+	cat >expect <<-EOF &&
+	# pack-refs with: peeled fully-peeled sorted
+	<COMMIT-B> refs/heads/topic/A
+	<COMMIT-B> refs/heads/topic/B
+	<COMMIT-D> refs/heads/topic/D
+	<COMMIT-D> refs/tags/tag-D
+	EOF
 	cat dest.git/packed-refs |
 		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual &&
+
+	test_loose_refs_count dest.git 4 &&
+	cat >expect <<-EOF &&
+	<COMMIT-C> HEAD
+	<COMMIT-C> refs/heads/main
+	<COMMIT-A> refs/heads/topic/A
+	<COMMIT-B> refs/heads/topic/B
+	<COMMIT-D> refs/heads/topic/D
+	<COMMIT-A> refs/tags/tag-A
+	<COMMIT-B> refs/tags/tag-B
+	<COMMIT-D> refs/tags/tag-D
+	EOF
+	git -C dest.git show-ref --head |
+		make_user_friendly_and_stable_output >actual &&
 	test_cmp expect actual
 '
 
diff --git a/t/t5594-remote-update-write-packed-refs.sh b/t/t5594-remote-update-write-packed-refs.sh
index 75ebaa0c29..7ed073e376 100755
--- a/t/t5594-remote-update-write-packed-refs.sh
+++ b/t/t5594-remote-update-write-packed-refs.sh
@@ -150,6 +150,14 @@ test_loose_refs_count () {
 	test_line_count = $EXPECTED_COUNT actual
 }
 
+test_loose_refs_count () {
+	DIR="$1/refs" &&
+	EXPECTED_COUNT="$2" &&
+	test_path_is_dir "$DIR" &&
+	find "$DIR" -type f >actual &&
+	test_line_count = $EXPECTED_COUNT actual
+}
+
 # workdir:
 #
 #   * main (C)
@@ -224,16 +232,25 @@ test_expect_success 'delete branch-B and change branch-C' '
 test_expect_success 'test fetch with --write-packed-refs' '
 	git -C dest.git \
 		remote update --write-packed-refs --prune &&
-	assert_no_loose &&
+
+	test_loose_refs_count dest.git 4 &&
 	cat >expect <<-EOF &&
 	# pack-refs with: peeled fully-peeled sorted
+	<COMMIT-B> refs/heads/branch-A
+	<COMMIT-D> refs/heads/branch-C
+	EOF
+	cat dest.git/packed-refs |
+		make_user_friendly_and_stable_output >actual &&
+	test_cmp expect actual &&
+
+	cat >expect <<-EOF &&
 	<COMMIT-A> refs/heads/branch-A
 	<COMMIT-D> refs/heads/branch-C
 	<COMMIT-A> refs/tags/tag-A
 	<COMMIT-B> refs/tags/tag-B
 	<COMMIT-C> refs/tags/tag-C
 	EOF
-	cat dest.git/packed-refs |
+	git -C dest.git show-ref --head |
 		make_user_friendly_and_stable_output >actual &&
 	test_cmp expect actual
 '
-- 
patchwork
