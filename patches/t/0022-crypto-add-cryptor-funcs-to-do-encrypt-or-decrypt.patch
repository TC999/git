From beb6fc37e1022babf160964e213b74dfb2bd6250 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E7=82=BD=E5=A4=A9?= <hanxin.hx@alibaba-inc.com>
Date: Tue, 29 Dec 2020 15:37:22 +0800
Subject: [PATCH 22/42] crypto: add cryptor funcs to do encrypt or decrypt

Signed-off-by: Han Xin <hanxin.hx@alibaba-inc.com>
Signed-off-by: Jiang Xin <zhiyou.jx@alibaba-inc.com>
---
 Documentation/config.txt      |   2 +
 Documentation/config/agit.txt |   8 +
 Makefile                      |   3 +
 config.mak.uname              |  14 ++
 crypto.c                      | 397 ++++++++++++++++++++++++++++++++++
 crypto.h                      | 120 ++++++++++
 6 files changed, 544 insertions(+)
 create mode 100644 Documentation/config/agit.txt
 create mode 100644 crypto.c
 create mode 100644 crypto.h

diff --git a/Documentation/config.txt b/Documentation/config.txt
index e284b042f2..d219599ca9 100644
--- a/Documentation/config.txt
+++ b/Documentation/config.txt
@@ -369,6 +369,8 @@ inventing new variables for use in your own tool, make sure their
 names do not conflict with those that are used by Git itself and
 other popular tools, and describe them in your documentation.
 
+include::config/agit.txt[]
+
 include::config/advice.txt[]
 
 include::config/core.txt[]
diff --git a/Documentation/config/agit.txt b/Documentation/config/agit.txt
new file mode 100644
index 0000000000..a8f61f59e4
--- /dev/null
+++ b/Documentation/config/agit.txt
@@ -0,0 +1,8 @@
+agit.crypto.enabled::
+	If crypto enabled or not.
+
+agit.crypto.secret::
+	Secret must be given if crypto enabled.
+
+agit.crypto.nonce::
+	Crypto nonce is optional.
diff --git a/Makefile b/Makefile
index 61aadf3ce8..5c5a562e3f 100644
--- a/Makefile
+++ b/Makefile
@@ -908,6 +908,7 @@ LIB_OBJS += connected.o
 LIB_OBJS += convert.o
 LIB_OBJS += copy.o
 LIB_OBJS += credential.o
+LIB_OBJS += crypto.o
 LIB_OBJS += csum-file.o
 LIB_OBJS += ctype.o
 LIB_OBJS += date.o
@@ -1521,6 +1522,8 @@ ifndef NO_OPENSSL
 	ifdef NEEDS_CRYPTO_WITH_SSL
 		OPENSSL_LIBSSL += -lcrypto
 	endif
+	# Alibaba git crypto need openssl: "-lssl -lcrypto"
+	EXTLIBS += $(LIB_4_CRYPTO)
 else
 	BASIC_CFLAGS += -DNO_OPENSSL
 	OPENSSL_LIBSSL =
diff --git a/config.mak.uname b/config.mak.uname
index 259d1511ca..8ef143b8c7 100644
--- a/config.mak.uname
+++ b/config.mak.uname
@@ -68,6 +68,8 @@ ifeq ($(uname_S),Linux)
 	ifneq ($(findstring .el7.,$(uname_R)),)
 		BASIC_CFLAGS += -std=c99
 	endif
+	# Alibaba git crypto needs: -lssl -lcrypto
+	NEEDS_SSL_WITH_CRYPTO = YesPlease
 endif
 ifeq ($(uname_S),GNU/kFreeBSD)
 	HAVE_ALLOCA_H = YesPlease
@@ -76,6 +78,8 @@ ifeq ($(uname_S),GNU/kFreeBSD)
 	DIR_HAS_BSD_GROUP_SEMANTICS = YesPlease
 	LIBC_CONTAINS_LIBINTL = YesPlease
 	FREAD_READS_DIRECTORIES = UnfortunatelyYes
+	# Alibaba git crypto needs: -lssl -lcrypto
+	NEEDS_SSL_WITH_CRYPTO = YesPlease
 endif
 ifeq ($(uname_S),UnixWare)
 	CC = cc
@@ -137,6 +141,16 @@ ifeq ($(uname_S),Darwin)
 	ifeq ($(shell test "`expr "$(uname_R)" : '\([0-9][0-9]*\)\.'`" -ge 20 && echo 1),1)
 		OPEN_RETURNS_EINTR = UnfortunatelyYes
 	endif
+	# NOTE: to encrypt pack and loose object, we use aes encrypt function in openssl.
+	NO_APPLE_COMMON_CRYPTO = YesPlease
+	OPENSSL_SHA1 = 1
+
+	# OpenSSL dirs
+	ifeq ($(shell test -d /usr/local/opt/openssl/ && echo y),y)
+		BASIC_CFLAGS += -I/usr/local/include -I/usr/local/opt/openssl/include
+		BASIC_LDFLAGS += -L/usr/local/lib -L/usr/local/opt/openssl/lib
+	endif
+
 	NO_MEMMEM = YesPlease
 	USE_ST_TIMESPEC = YesPlease
 	HAVE_DEV_TTY = YesPlease
diff --git a/crypto.c b/crypto.c
new file mode 100644
index 0000000000..d9c4582184
--- /dev/null
+++ b/crypto.c
@@ -0,0 +1,397 @@
+/*
+ * crypt.c - crypto wrapper
+ *
+ * Copyright (C) 2020 Chi Tian <hanxin.hx@alibaba-inc.com>
+ */
+#include "git-compat-util.h"
+#include "crypto.h"
+#include "pack.h"
+
+const char *agit_crypto_secret;
+const char *agit_crypto_nonce;
+int agit_crypto_enabled;
+int agit_crypto_default_algorithm;
+
+static int srand_once;
+
+static inline enum agit_crypto_algo
+crypto_get_algo_from_net_version(uint32_t net_version)
+{
+	return (ntohl(net_version) >> 24) & 0x7f;
+}
+
+int crypto_pack_has_longer_nonce_for_algo(int algo)
+{
+	/* Encrypt algorithm 64 - 95 (10x xxxx) has a 2-bytes nonce/slat */
+	if (algo >= 64 && algo <= 95)
+		return 0;
+	/* Encrypt algorithm 1 - 63 (0xx xxxx) has a 12-bytes nonce */
+	if (algo < 64 && algo > 0)
+		return 1;
+	die("unsupported algo: %d", algo);
+}
+
+int crypto_pack_has_longer_nonce_for_version(uint32_t net_version)
+{
+	return crypto_pack_has_longer_nonce_for_algo(
+		crypto_get_algo_from_net_version(net_version));
+}
+
+static int crypto_packfile_nonce_length(int algo)
+{
+	if (crypto_pack_has_longer_nonce_for_algo(algo))
+		return NONCE_LEN;
+	else
+		return 2; /* salt in the 6/7th bytes of header */
+}
+
+/*
+ * The 1st bit is always 1, which indicates pack or loose object is encrypted.
+ */
+static enum agit_crypto_algo crypto_new_algorithim(enum agit_crypto_algo algo)
+{
+	switch (algo) {
+	default:
+		die("bad algorithm: %x\n", algo);
+		break;
+	case GIT_CRYPTO_ALGORITHM_BENCHMARK:
+		/* fallthrough */
+	case GIT_CRYPTO_ALGORITHM_AES:
+		/* fallthrough */
+	case GIT_CRYPTO_ALGORITHM_EASY_BENCHMARK:
+		/* fallthrough */
+	case GIT_CRYPTO_ALGORITHM_EASY_AES:
+		break;
+	}
+
+	return algo;
+}
+
+/*
+ * Setup secret sequence for each block, and returns length of
+ * sequence generated.
+ */
+static int gen_sec_sequence_benchmark(git_cryptor *cryptor, unsigned char *seq,
+				      uint32_t len)
+{
+	/* pos = cryptor->byte_counter / 16 */
+	uint32_t pos_n = htonl(cryptor->byte_counter >> 4);
+	int ret = 16;
+	/* mix test writes 16 bytes */
+	assert(len >= ret);
+
+	if (pos_n != 0 && pos_n == cryptor->pos_n_last)
+		return ret;
+	else
+		cryptor->pos_n_last = pos_n;
+
+	memcpy(cryptor->nonce + NONCE_LEN, &pos_n, sizeof(uint32_t));
+	/* do nothing for seq */
+	return ret;
+}
+
+/*
+ * Setup secret sequence for each block, and returns length of
+ * sequence generated.
+ */
+static int gen_sec_sequence_aes(git_cryptor *cryptor, unsigned char *seq,
+				 uint32_t len)
+{
+	/* pos = cryptor->byte_counter / 16 */
+	uint32_t pos_n = htonl(cryptor->byte_counter >> 4);
+	int ret = 16, ciphertext_len;
+	/* aes writes 16 bytes */
+	assert(len >= ret);
+
+	if (pos_n != 0 && pos_n == cryptor->pos_n_last)
+		return ret;
+	else
+		cryptor->pos_n_last = pos_n;
+
+	memcpy(cryptor->nonce + NONCE_LEN, &pos_n, sizeof(uint32_t));
+
+	if (1 != EVP_EncryptUpdate(cryptor->ctx, seq, &ciphertext_len,
+				   (const unsigned char *)cryptor->nonce, ret))
+		die("aes encrypt nonce failed");
+	assert(ciphertext_len == ret);
+	return ret;
+}
+
+static void git_decrypt(git_cryptor *cryptor, const unsigned char *in,
+			unsigned char *out, size_t avail_in, size_t avail_out)
+{
+	int sec_seq_init = 0, sec_seq_len, i, pos, post_avail;
+	size_t avail = avail_in < avail_out ? avail_in : avail_out;
+
+	while (avail) {
+		if (!sec_seq_init) {
+			sec_seq_len = cryptor->gen_sec_sequence(
+				cryptor, cryptor->secret_sequence,
+				sizeof(cryptor->secret_sequence));
+			pos = cryptor->byte_counter & (sec_seq_len - 1);
+			sec_seq_init = 1;
+		} else if (pos == 0)
+			sec_seq_len = cryptor->gen_sec_sequence(
+				cryptor, cryptor->secret_sequence,
+				sizeof(cryptor->secret_sequence));
+
+		post_avail = (sec_seq_len - pos) < avail ? sec_seq_len - pos :
+							   avail;
+
+		for (i = 0; i < post_avail; i++) {
+			/* encrypt one byte */
+			*out++ = *in++ ^ cryptor->secret_sequence[
+				pos++ & (sec_seq_len - 1)];
+		}
+
+		pos = 0;
+		cryptor->byte_counter += i;
+		avail -= i;
+	}
+}
+
+static void git_encrypt(git_cryptor *cryptor, const unsigned char *in,
+			unsigned char *out, size_t avail_in)
+{
+	cryptor->decrypt(cryptor, in, out, avail_in, avail_in);
+}
+
+static int git_crypto_get_secret(unsigned char **secret)
+{
+	const char *input_secret = agit_crypto_secret;
+	int input_len;
+	int base64_decode = -1;
+	int len;
+
+	if (!input_secret)
+		die("crypto secret is unset");
+
+	if (!strncasecmp(input_secret, "{base64}", 8)) {
+		input_secret += 8;
+		base64_decode = 1;
+	} else if (!strncasecmp(input_secret, "{plain}", 7)) {
+		input_secret += 7;
+		base64_decode = 0;
+	}
+	input_len = strlen(input_secret);
+	if (input_len < 8)
+		die("secret token is too short");
+
+	/* Password padding: make sure have 16 or more characters,
+	 * because random data may try to fill 16 secret characters. */
+	len = input_len > 16 ? input_len: 16;
+	*secret = xmalloc(len);
+	memset(*secret, 0, len);
+	if (!base64_decode) {
+		memcpy(*secret, input_secret, input_len);
+	} else {
+		len = EVP_DecodeBlock(
+			*secret, (const unsigned char *)input_secret,
+			input_len);
+		if (len <= 0) {
+			if (base64_decode == 1)
+				die("decode secret failed");
+			len = input_len;
+			memcpy(*secret, input_secret, input_len);
+		}
+		/* Random data will fill to pad 16 characters if len < 16. */
+		if (len < 16) {
+			len = 16;
+		}
+	}
+	return len;
+}
+
+/* set up crypto method */
+static void git_crypto_setup(git_cryptor *cryptor)
+{
+	unsigned char *secret = NULL;
+	int secret_len;
+
+	secret_len = git_crypto_get_secret(&secret);
+
+	cryptor->encrypt = &git_encrypt;
+	cryptor->decrypt = &git_decrypt;
+
+	switch (cryptor->algorithm) {
+	case GIT_CRYPTO_ALGORITHM_BENCHMARK:
+	case GIT_CRYPTO_ALGORITHM_EASY_BENCHMARK:
+		{
+		git_SHA256_CTX ctx;
+		git_SHA256_Init(&ctx);
+		git_SHA256_Update(&ctx, secret, secret_len);
+		git_SHA256_Final(cryptor->secret_sequence, &ctx);
+		cryptor->gen_sec_sequence = &gen_sec_sequence_benchmark;
+		}
+		break;
+	case GIT_CRYPTO_ALGORITHM_AES:
+	case GIT_CRYPTO_ALGORITHM_EASY_AES:
+		{
+		if (!(cryptor->ctx = EVP_CIPHER_CTX_new()))
+			die("new aes ctx failed");
+
+		if (secret_len >= 32) {
+			if (!(EVP_EncryptInit_ex(cryptor->ctx,
+						 EVP_aes_256_ecb(), NULL,
+						 secret, NULL)))
+				die("setup aes256 encrypt key failed");
+		} else if (secret_len >= 24) {
+			if (!(EVP_EncryptInit_ex(cryptor->ctx,
+						 EVP_aes_192_ecb(), NULL,
+						 secret, NULL)))
+				die("setup aes192 encrypt key failed");
+		} else {
+			if (!(EVP_EncryptInit_ex(cryptor->ctx,
+						 EVP_aes_128_ecb(), NULL,
+						 secret, NULL)))
+				die("setup aes128 encrypt key failed");
+		}
+
+		cryptor->gen_sec_sequence = &gen_sec_sequence_aes;
+		}
+		break;
+	default:
+		die("crypto cipher type %d not supported", cryptor->algorithm);
+	}
+
+	free(secret);
+}
+
+/* init git cryptor or die password not given */
+void git_encryptor_init_or_die(git_cryptor *cryptor, int is_pack)
+{
+	int algo_type;
+	char *env;
+	int nonce_len;
+
+	if (!agit_crypto_secret)
+		die("try encryption but agit.crypto.secret not given");
+
+	env = getenv("GIT_TEST_CRYPTO_ALGORITHM_TYPE");
+	if (env && *env != '\0')
+		algo_type = atoi(env);
+	else if (agit_crypto_default_algorithm)
+		algo_type = agit_crypto_default_algorithm;
+	else
+		algo_type = GIT_CRYPTO_ALGORITHM_DEFAULT;
+	nonce_len = is_pack ? crypto_packfile_nonce_length(algo_type) :
+			      NONCE_LEN;
+	memset(cryptor, 0, sizeof(*cryptor));
+	cryptor->algorithm = crypto_new_algorithim(algo_type);
+	if (agit_crypto_nonce) {
+		int len = strlen(agit_crypto_nonce);
+		if (len > nonce_len)
+			len = nonce_len;
+		memcpy(cryptor->nonce, agit_crypto_nonce, len);
+	} else {
+		if (nonce_len == NONCE_LEN) { /* Has longer nonce (12 bytes) */
+			uint64_t *tm = (uint64_t *)(cryptor->nonce);
+			uint32_t *pid = (uint32_t *)(cryptor->nonce+8);
+			uint32_t *hdr = (uint32_t *)(cryptor->nonce);
+			*tm = getnanotime();
+			*pid = (uint32_t)getpid();
+			/* Mask for header of nonce: PACK(0x5041434b) or LOSE(0x4c4f5345) */
+			*hdr ^= is_pack? 0x5041434b : 0x4c4f5345;
+			/* Mask for tailer of nonce: XHTC(0x58485443) or XJYZ(0x584a595a)*/
+			*pid ^= is_pack? 0x58485443 : 0x584a595a;
+		} else { /* Only 2-byte nonce */
+			uint16_t *salt = (uint16_t *)(cryptor->nonce);
+			if (!srand_once) {
+				srand((unsigned)time(NULL));
+				srand_once = 1;
+			}
+			*salt = (uint16_t)rand();
+		}
+	}
+	git_crypto_setup(cryptor);
+}
+
+/*
+ * Init git decryptor or die password not given.
+ * The input hdr_version is in network byte order.
+ */
+void git_decryptor_init_or_die(git_cryptor *cryptor,
+			       const uint32_t net_hdr_version,
+			       unsigned char *nonce)
+{
+	uint32_t host_hdr_version = ntohl(net_hdr_version) & 0x7FFFFFFF;
+	int algo_type;
+
+	if (!agit_crypto_secret) {
+		die("try decryption but agit.crypto.secret not given");
+	}
+	memset(cryptor, 0, sizeof(*cryptor));
+	algo_type = host_hdr_version >> 24;
+
+	/* Valid algorithm: 00xx xxxx ~ 010x xxxx */
+	cryptor->algorithm = crypto_new_algorithim(algo_type);
+
+	if (!nonce) {
+		cryptor->nonce[0] = ((host_hdr_version >> 8) & 0x0000ff);
+		cryptor->nonce[1] = ((host_hdr_version >> 16) & 0x0000ff);
+	} else {
+		memcpy(cryptor->nonce, nonce, NONCE_LEN);
+	}
+	git_crypto_setup(cryptor);
+}
+
+/*
+ * Return version of encrypted packet in "host byte order" for packfile,
+ * The 4-byte version has different format for different algorithm :
+ *
+ * For algorithm 1 - 63:
+ *  + the 1st byte     : algorithm type
+ *  + the 2nd/3rd byte : reserved
+ *  + the 4th byte     : PACK_VERSION
+ *
+ * For algorithm 64 - 95:
+ *  + the 1st byte     : algorithm type
+ *  + the 2nd/3rd byte : a 2-byte salt
+ *  + the 4th byte     : PACK_VERSION
+ */
+uint32_t git_encryptor_get_host_pack_version(git_cryptor *cryptor,
+					     unsigned char *nonce)
+{
+	uint32_t ret = 0x80000000 | PACK_VERSION;
+
+	if (cryptor->algorithm > 96)
+		die("unimplemented encrypt algorithm: %d", cryptor->algorithm);
+	ret |= cryptor->algorithm << 24;
+	/* 2-byte nonce in header */
+	if (crypto_packfile_nonce_length(cryptor->algorithm) == 2) {
+		ret |= cryptor->nonce[0] << 8;
+		ret |= cryptor->nonce[1] << 16;
+	} else if (nonce) {
+		memcpy(nonce, cryptor->nonce, NONCE_LEN);
+	}
+	return ret;
+}
+
+/*
+ * Return 20 bytes encrypted object header in "network byte order",
+ * which include: signature + version
+ *
+ *  + 4 bytes signature: ENC\0
+ *  + 4 bytes version  :
+ *      * 1 byte type
+ *      * 3 bytes reserved
+ *  + 12 bytes nonce
+ *
+ * Note: If *header is NULL, it's caller's duty to free the allocated header.
+ */
+unsigned char *git_encryptor_get_net_object_header(git_cryptor *cryptor,
+						   unsigned char *header)
+{
+	uint32_t htonl_version;
+
+	if (header == NULL)
+		header = xcalloc(1, GIT_CRYPTO_LO_HEADER_SIZE);
+	else
+		memset(header, 0, GIT_CRYPTO_LO_HEADER_SIZE);
+
+	memcpy(header, git_crypto_lo_signature, 4);
+	htonl_version = htonl(0x80000000 | (cryptor->algorithm << 24));
+	memcpy(header + 4, &htonl_version, 4);
+	memcpy(header + 8, cryptor->nonce, NONCE_LEN);
+	return header;
+}
diff --git a/crypto.h b/crypto.h
new file mode 100644
index 0000000000..63b418ae61
--- /dev/null
+++ b/crypto.h
@@ -0,0 +1,120 @@
+#ifndef CRYPTO_H
+#define CRYPTO_H
+
+#ifdef NO_OPENSSL
+#error re-configure using "--with-openssl=path/of/openssl" to build git-crypto
+#endif
+
+#include <openssl/evp.h>
+
+/*
+ * The first bit of pack version (network byte order)
+ * indicates that the packfile is encrypted.
+ */
+#define git_crypto_pack_is_encrypt(v)	(ntohl(v) >> 31)
+
+#define NONCE_LEN 12
+/*
+ * The first 4 bytes of a header is signature.
+ * Signature for encrypted loose object is "ENC\0".
+ */
+#define GIT_CRYPTO_LO_HEADER_SIZE	20
+static const unsigned char git_crypto_lo_signature[4] = {
+	'E', 'N', 'C', '\0'
+};
+#define git_crypto_lo_has_signature(s)	(!memcmp(s, git_crypto_lo_signature, 4))
+
+/*
+ * The 5th byte of the header defines crypto algorithm.
+ * The most significant bit indicates encryption status.
+ *
+ * 0xxx xxxx : no encryption.
+ *
+ * 10xx xxxx : encrypt algorithm 0 - 63 (0xx xxxx),
+ *             which has an extend header (24 bytes total), the
+ *             additional 12 bytes used as nonce for cryptology.
+ *
+ * 110x xxxx : encrypt algorithm 64 - 95 (10x xxxx),
+ *             which has a normal fixed 12-byte header, and
+ *             the 6/7th bytes as salt.
+ *
+ * 1110 xxxx xxxx xxxx xxxx xxxx : encrypt algorithm 96 - 1048671,
+ *             which is reserved for future use.
+ */
+
+/* Algorithm */
+enum agit_crypto_algo {
+	/* Algorithm 1 - 63 (0xx xxxx), which has an additional
+	 * 12 bytes used as nonce for cryption */
+	GIT_CRYPTO_ALGORITHM_BENCHMARK = 1, /* test only, do not use in
+					       production */
+	GIT_CRYPTO_ALGORITHM_AES = 2,
+
+	/* Algorithm 64 - 95 (10x xxxx), which used normal header,
+	 * and the 6/7th bytes are used as 2-byte salt. */
+	GIT_CRYPTO_ALGORITHM_EASY_BENCHMARK = 64, /* test only, do not use in
+						     production */
+	GIT_CRYPTO_ALGORITHM_EASY_AES = 65
+};
+#define GIT_CRYPTO_ALGORITHM_DEFAULT GIT_CRYPTO_ALGORITHM_AES
+
+/*
+ * The 6th and 7th bytes are preserved for later use.
+ *
+ * The 8th byte of the header is version for packfile, or reserved
+ * for loose object.
+ */
+
+extern const char *agit_crypto_secret;
+extern const char *agit_crypto_nonce;
+/* enable git crypto will make sha-file or packfile encrypted */
+extern int agit_crypto_enabled;
+extern int agit_crypto_default_algorithm;
+
+typedef struct git_cryptor {
+	enum agit_crypto_algo algorithm;
+	unsigned char nonce[NONCE_LEN + 4];
+	size_t byte_counter;
+	/* Must allocate secret_sequence longer enough for HASH function.
+	 * SHA256 hash needs 32 bytes.
+	 */
+	unsigned char secret_sequence[32];
+	uint32_t pos_n_last;
+	EVP_CIPHER_CTX *ctx;
+
+	/* gen secret sequence  */
+	int (*gen_sec_sequence)(struct git_cryptor *, unsigned char *seq,
+				uint32_t len);
+
+	/* do git encrypt with given input and write to out */
+	void (*encrypt)(struct git_cryptor *, const unsigned char *in,
+			unsigned char *out, size_t avail_in);
+
+	/* do git decrypt with given input and write to out */
+	void (*decrypt)(struct git_cryptor *, const unsigned char *in,
+			unsigned char *out, size_t avail_in, size_t avail_out);
+} git_cryptor;
+
+int crypto_pack_has_longer_nonce_for_version(uint32_t net_version);
+
+int crypto_pack_has_longer_nonce_for_algo(int algo);
+
+/* init git encryptor or die password not given */
+void git_encryptor_init_or_die(git_cryptor *cryptor, int is_pack);
+
+#define git_encryptor_init_for_loose_object(v) git_encryptor_init_or_die(v, 0)
+#define git_encryptor_init_for_packfile(v) git_encryptor_init_or_die(v, 1)
+
+/* init git decryptor or die password not given */
+void git_decryptor_init_or_die(git_cryptor *, uint32_t hdr_version,
+			       unsigned char *nonce);
+
+/* get pack version */
+uint32_t git_encryptor_get_host_pack_version(git_cryptor *,
+					     unsigned char *nonce);
+
+/* get cryptor header */
+unsigned char *git_encryptor_get_net_object_header(git_cryptor *,
+						   unsigned char *header);
+
+#endif
-- 
patchwork
