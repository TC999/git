From a26db9a9bc4ca7029e50a17aba9d8ff215434d90 Mon Sep 17 00:00:00 2001
From: Han Xin <hanxin.hx@alibaba-inc.com>
Date: Wed, 23 Mar 2022 20:33:10 +0800
Subject: [PATCH] gc: do gc if there are to many loose refs

The native automatic gc is only triggered when there are too many loose
objects or too many packfiles, but it will not trigger when too many
loose references are created. A large number of loose references may
lead to more IO operations.

To improve this, lets add a configuration "gc.autoLooseRefsLimit" which
will also trigger automatic gc when there are more than this loose
references.

Edit:

 * Jiang Xin:
   + 2022/8/10: release buf to fix memory leak in if_too_many_loose_refs().
   + 2022/8/10: ignore "*.lock" files when checking loose refs.

Signed-off-by: Han Xin <hanxin.hx@alibaba-inc.com>
Signed-off-by: Jiang Xin <zhiyou.jx@alibaba-inc.com>
---
 Documentation/config/gc.txt |  6 +++++
 builtin/gc.c                | 45 ++++++++++++++++++++++++++++++++++++-
 t/t6500-gc.sh               | 13 +++++++++++
 3 files changed, 63 insertions(+), 1 deletion(-)

diff --git a/Documentation/config/gc.txt b/Documentation/config/gc.txt
index c834e07991..d9cf8615d3 100644
--- a/Documentation/config/gc.txt
+++ b/Documentation/config/gc.txt
@@ -38,6 +38,12 @@ gc.autoPackLimit::
 See the `gc.bigPackThreshold` configuration variable below. When in
 use, it'll affect how the auto pack limit works.
 
+gc.autoLooseRefsLimit::
+	When there are more than this many loose references., `git gc
+	--auto` consolidates them into packed-refs.  The default value
+	is 50.  Setting this to 0 disables it. Setting `gc.auto` to 0
+	will also disable this.
+
 gc.autoDetach::
 	Make `git gc --auto` return immediately and run in background
 	if the system supports it. Default is true.
diff --git a/builtin/gc.c b/builtin/gc.c
index b335cffa33..824845baec 100644
--- a/builtin/gc.c
+++ b/builtin/gc.c
@@ -46,6 +46,7 @@ static int aggressive_depth = 50;
 static int aggressive_window = 250;
 static int gc_auto_threshold = 6700;
 static int gc_auto_pack_limit = 50;
+static int gc_auto_loose_refs_limit = 50;
 static int detach_auto = 1;
 static timestamp_t gc_log_expire_time;
 static const char *gc_log_expire = "1.day.ago";
@@ -151,6 +152,7 @@ static void gc_config(void)
 	git_config_get_int("gc.aggressivedepth", &aggressive_depth);
 	git_config_get_int("gc.auto", &gc_auto_threshold);
 	git_config_get_int("gc.autopacklimit", &gc_auto_pack_limit);
+	git_config_get_int("gc.autolooserefslimit", &gc_auto_loose_refs_limit);
 	git_config_get_bool("gc.autodetach", &detach_auto);
 	git_config_get_expiry("gc.pruneexpire", &prune_expire);
 	git_config_get_expiry("gc.worktreepruneexpire", &prune_worktrees_expire);
@@ -248,6 +250,47 @@ static int too_many_packs(void)
 	return gc_auto_pack_limit < cnt;
 }
 
+static int if_too_many_loose_refs(const char *path, int *count)
+{
+	int ret = 0;
+	DIR *dir = opendir(path);
+	struct dirent *ent;
+	static struct strbuf buf = STRBUF_INIT;
+	if (!dir)
+		return 0;
+
+	while ((ent = readdir(dir)) != NULL) {
+		if (ent->d_name[0] == '.')
+			continue;
+		if (ends_with(ent->d_name, ".lock"))
+			continue;
+		if (ent->d_type == DT_DIR) {
+			strbuf_reset(&buf);
+			strbuf_addf(&buf, "%s/%s", path, ent->d_name);
+			ret = if_too_many_loose_refs(buf.buf, count);
+			if (ret)
+				break;
+		} else if (++*count > gc_auto_loose_refs_limit) {
+			ret = 1;
+			break;
+		}
+	}
+
+	closedir(dir);
+	strbuf_release(&buf);
+	return ret;
+}
+
+static int too_many_loose_refs(void)
+{
+	int num_loose = 0;
+
+	if (gc_auto_loose_refs_limit <= 0)
+		return 0;
+
+	return if_too_many_loose_refs(git_path("refs"), &num_loose);
+}
+
 static uint64_t total_ram(void)
 {
 #if defined(HAVE_SYSINFO)
@@ -389,7 +432,7 @@ static int need_to_gc(void)
 
 		add_repack_all_option(&keep_pack);
 		string_list_clear(&keep_pack, 0);
-	} else if (too_many_loose_objects())
+	} else if (too_many_loose_objects() || too_many_loose_refs())
 		add_repack_incremental_option();
 	else
 		return 0;
diff --git a/t/t6500-gc.sh b/t/t6500-gc.sh
index cd6c53360d..dcd940002f 100755
--- a/t/t6500-gc.sh
+++ b/t/t6500-gc.sh
@@ -163,6 +163,19 @@ test_expect_success 'auto gc with too many loose objects does not attempt to cre
 	test_line_count = 1 new # There is one new pack
 '
 
+test_expect_success 'auto gc with too many loose refs' '
+	test_config gc.autolooserefslimit 5 &&
+	git branch loose-refs-1 &&
+	git gc --auto &&
+	test_stdout_line_count -ge 0 find .git/refs -type f &&
+	git branch loose-refs-2 &&
+	git branch loose-refs-3 &&
+	git branch loose-refs-4 &&
+	git branch loose-refs-5 &&
+	git gc --auto &&
+	test_stdout_line_count = 0 find .git/refs -type f
+'
+
 test_expect_success 'gc --no-quiet' '
 	GIT_PROGRESS_DELAY=0 git -c gc.writeCommitGraph=true gc --no-quiet >stdout 2>stderr &&
 	test_must_be_empty stdout &&
-- 
patchwork
