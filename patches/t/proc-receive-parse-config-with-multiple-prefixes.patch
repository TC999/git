From 06d82e5128cd4bc1e7b6fce0ed5b3cfdd3477674 Mon Sep 17 00:00:00 2001
From: Jiang Xin <zhiyou.jx@alibaba-inc.com>
Date: Sun, 28 Mar 2021 09:25:06 +0800
Subject: [PATCH] proc-receive: parse config with multiple prefixes

Can take multiple prefixes in one receive.procReceiveRefs setting.  So
we can handle all references other than heads and tags.  E.g.:

    git config --add \
        receive.procReceiveRefs "!:refs/heads,refs/tags"

Edit:

 * [Jiang Xin, 2022-09-01] replace strsep with strtok for compatiblity
   for build on Windows.

Signed-off-by: Jiang Xin <zhiyou.jx@alibaba-inc.com>
---
 builtin/receive-pack.c                 |  65 +++++++--
 t/t5411/once-0020-proc-receive-refs.sh | 178 +++++++++++++++++++++++++
 2 files changed, 230 insertions(+), 13 deletions(-)
 create mode 100644 t/t5411/once-0020-proc-receive-refs.sh

diff --git a/builtin/receive-pack.c b/builtin/receive-pack.c
index 9aabffa1af..0cd0680389 100644
--- a/builtin/receive-pack.c
+++ b/builtin/receive-pack.c
@@ -100,12 +100,17 @@ static int keepalive_in_sec = 5;
 
 static struct tmp_objdir *tmp_objdir;
 
+struct ref_prefix {
+	char *prefix;
+	struct ref_prefix *next;
+};
+
 static struct proc_receive_ref {
 	unsigned int want_add:1,
 		     want_delete:1,
 		     want_modify:1,
 		     negative_ref:1;
-	char *ref_prefix;
+	struct ref_prefix *ref_prefix;
 	struct proc_receive_ref *next;
 } *proc_receive_ref;
 
@@ -360,10 +365,12 @@ struct command {
 static void proc_receive_ref_append(const char *prefix)
 {
 	struct proc_receive_ref *ref_pattern;
+	struct ref_prefix **ref_pp;
 	char *p;
 	int len;
 
 	CALLOC_ARRAY(ref_pattern, 1);
+	ref_pp = &ref_pattern->ref_prefix;
 	p = strchr(prefix, ':');
 	if (p) {
 		while (prefix < p) {
@@ -378,15 +385,29 @@ static void proc_receive_ref_append(const char *prefix)
 			prefix++;
 		}
 		prefix++;
-	} else {
+	}
+	if (!ref_pattern->want_add &&
+	    !ref_pattern->want_delete &&
+	    !ref_pattern->want_modify) {
 		ref_pattern->want_add = 1;
 		ref_pattern->want_delete = 1;
 		ref_pattern->want_modify = 1;
 	}
-	len = strlen(prefix);
-	while (len && prefix[len - 1] == '/')
-		len--;
-	ref_pattern->ref_prefix = xmemdupz(prefix, len);
+	for (p = strtok((char *)prefix, ","); p; p = strtok(NULL, ",")) {
+		len = strlen(p);
+		while (len && p[len - 1] == '/')
+			len--;
+		if (strncmp(p, "refs/", 5) && strcmp(p, "refs")) {
+			fprintf(stderr, "prefix '%s' not start with 'refs/'", prefix);
+			continue;
+		}
+		*ref_pp = xcalloc(1, sizeof(struct ref_prefix));
+		(*ref_pp)->prefix = xmemdupz(p, len);
+		ref_pp = &(*ref_pp)->next;
+	}
+	if (!ref_pattern->ref_prefix)
+		goto cleanup;
+
 	if (!proc_receive_ref) {
 		proc_receive_ref = ref_pattern;
 	} else {
@@ -397,18 +418,30 @@ static void proc_receive_ref_append(const char *prefix)
 			end = end->next;
 		end->next = ref_pattern;
 	}
+	return;
+
+cleanup:
+	for (ref_pp = &ref_pattern->ref_prefix; *ref_pp;) {
+		struct ref_prefix **pp;
+		pp = &(*ref_pp)->next;
+		free((*ref_pp)->prefix);
+		free((*ref_pp));
+		ref_pp = pp;
+	}
+	free(ref_pattern);
 }
 
 static int proc_receive_ref_matches(struct command *cmd)
 {
 	struct proc_receive_ref *p;
+	struct ref_prefix *ref_prefix;
 
 	if (!proc_receive_ref)
 		return 0;
 
 	for (p = proc_receive_ref; p; p = p->next) {
-		const char *match = p->ref_prefix;
 		const char *remains;
+		int match = 0;
 
 		if (!p->want_add && is_null_oid(&cmd->old_oid))
 			continue;
@@ -419,13 +452,19 @@ static int proc_receive_ref_matches(struct command *cmd)
 			 !is_null_oid(&cmd->new_oid))
 			continue;
 
-		if (skip_prefix(cmd->ref_name, match, &remains) &&
-		    (!*remains || *remains == '/')) {
-			if (!p->negative_ref)
-				return 1;
-		} else if (p->negative_ref) {
-			return 1;
+		for (ref_prefix = p->ref_prefix; ref_prefix;
+		     ref_prefix = ref_prefix->next) {
+			if (skip_prefix(cmd->ref_name, ref_prefix->prefix,
+					&remains) &&
+			    (!*remains || *remains == '/')) {
+				match = 1;
+				break;
+			}
 		}
+		if (match && !p->negative_ref)
+			return 1;
+		else if (!match && p->negative_ref)
+			return 1;
 	}
 	return 0;
 }
diff --git a/t/t5411/once-0020-proc-receive-refs.sh b/t/t5411/once-0020-proc-receive-refs.sh
new file mode 100644
index 0000000000..d7b30c1e8f
--- /dev/null
+++ b/t/t5411/once-0020-proc-receive-refs.sh
@@ -0,0 +1,178 @@
+test_expect_success "setup receive.procReceiveRefs" '
+	git clone --mirror "$upstream" test-config.git &&
+	git -C test-config.git config receive.procReceiveRefs "refs/for,refs/review" &&
+	git clone test-config.git test-config
+'
+
+# Refs of upstream : main(B)
+# Refs of workbench: main(B)
+# git push         : (A)
+test_expect_success "can push to refs/heads/main" '
+	(
+		cd test-config &&
+		git push -f origin $A:main >out 2>&1 &&
+		make_user_friendly_and_stable_output <out
+	) | tail -1 >actual &&
+	cat >expect <<-\EOF &&
+	 + <COMMIT-B>...<COMMIT-A> <COMMIT-A> -> main (forced update)
+	EOF
+	test_cmp expect actual
+'
+
+# Refs of upstream : main(A)
+# Refs of workbench: main(B)
+# git push         :            refs/pull/123/head(B)
+test_expect_success "can push to refs/pull/123/head" '
+	(
+		cd test-config &&
+		git push origin $B:refs/pull/123/head >out 2>&1 &&
+		make_user_friendly_and_stable_output <out
+	) | tail -1 >actual &&
+	cat >expect <<-\EOF &&
+	 * [new reference]   <COMMIT-B> -> refs/pull/123/head
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success "need proc-receive hook when pushing refs/for/..." '
+	test_must_fail git -C test-config push \
+		origin HEAD:refs/for/main/topic1 >actual 2>&1 &&
+	grep "fail to run proc-receive hook" actual
+'
+
+test_expect_success "need proc-receive hook when pushing refs/review/..." '
+	test_must_fail git -C test-config push \
+		origin HEAD:refs/review/123 >actual 2>&1 &&
+	grep "fail to run proc-receive hook" actual
+'
+
+test_expect_success "setup receive.procReceiveRefs" '
+	git -C test-config.git config --unset-all receive.procReceiveRefs &&
+	git -C test-config.git config receive.procReceiveRefs "!:refs/heads,refs/tags"
+'
+
+# Refs of upstream : main(A)  refs/pull/123/head(B)
+# Refs of workbench: main(B)
+# git push         : (B)
+test_expect_success "can push to refs/heads/main" '
+	git -C test-config push origin $B:main >out 2>&1 &&
+	make_user_friendly_and_stable_output <out |
+	tail -1 >actual &&
+	cat >expect <<-\EOF &&
+	   <COMMIT-A>..<COMMIT-B>  <COMMIT-B> -> main
+	EOF
+	test_cmp expect actual
+'
+
+# Refs of upstream : main(A)  refs/pull/123/head(B)
+# Refs of workbench: main(B)
+# git push         :                                   refs/tags/test-v1(B)
+test_expect_success "can push to refs/tags/test-v1" '
+	(
+		cd test-config &&
+		git push origin $A:refs/tags/test-v1 >out 2>&1 &&
+		make_user_friendly_and_stable_output <out
+	) | tail -1 >actual &&
+	cat >expect <<-\EOF &&
+	 * [new tag]         <COMMIT-A> -> test-v1
+	EOF
+	test_cmp expect actual
+'
+
+# Refs of upstream : main(B)  refs/pull/123/head(B)  refs/tags/test-v1
+# Refs of workbench: main(B)
+# git push                      refs/pull/123/head(B)
+test_expect_success "refs/pull/123/head is up-to-date" '
+	git -C test-config push \
+		origin $B:refs/pull/123/head >actual 2>&1 &&
+	cat >expect <<-\EOF &&
+	Everything up-to-date
+	EOF
+	test_cmp expect actual
+'
+
+# Refs of upstream : main(B)  refs/pull/123/head(B)  refs/tags/test-v1
+# Refs of workbench: main(B)
+# git push                      refs/pull/123/head(A)
+test_expect_success "need proc-receive to update refs/pull/123/head" '
+	test_must_fail git -C test-config push -f \
+		origin $A:refs/pull/123/head >actual 2>&1 &&
+	grep "fail to run proc-receive hook" actual
+'
+
+# Refs of upstream : main(B)  refs/pull/123/head(B)  refs/tags/test-v1
+# Refs of workbench: main(B)
+# git push                                                                 refs/for/main/topic1
+test_expect_success "need proc-receive to push refs/for/main/topic" '
+	test_must_fail git -C test-config push \
+		origin $A:refs/for/main/topic >actual 2>&1 &&
+	grep "fail to run proc-receive hook" actual
+'
+
+test_expect_success "setup receive.procReceiveRefs" '
+	git -C test-config.git update-ref -d refs/tags/test-v1 &&
+	git -C test-config.git update-ref -d refs/pull/123/head &&
+	git -C test-config.git config --unset-all receive.procReceiveRefs &&
+	git -C test-config.git config --add receive.procReceiveRefs "!:refs/heads,refs/tags" &&
+	git -C test-config.git config --add receive.procReceiveRefs "ad:refs/heads" &&
+	git -C test-config.git config --add receive.procReceiveRefs "refs/tags"
+'
+
+# Refs of upstream : main(B)
+# Refs of workbench: main(B)
+# git push         : (A)
+test_expect_success "can push to refs/heads/main" '
+	git -C test-config push -f \
+		origin $A:main >out 2>&1 &&
+	make_user_friendly_and_stable_output <out |
+	tail -1 >actual &&
+	cat >expect <<-\EOF &&
+	 + <COMMIT-B>...<COMMIT-A> <COMMIT-A> -> main (forced update)
+	EOF
+	test_cmp expect actual
+'
+
+# Refs of upstream : main(B)
+# Refs of workbench: main(B)
+# git push         :            topic1(A)
+test_expect_success "need proc-receive-hook to add new branch" '
+	test_must_fail git -C test-config push \
+		origin $A:refs/heads/topic1 >actual 2>&1 &&
+	grep "fail to run proc-receive hook" actual
+'
+
+# Refs of upstream : main(B)
+# Refs of workbench: main(B)
+# git push         : (delete)
+test_expect_success "need proc-receive-hook to remove branch" '
+	test_must_fail git -C test-config push \
+		origin :refs/heads/main >actual 2>&1 &&
+	grep "fail to run proc-receive hook" actual
+'
+
+# Refs of upstream : main(B)
+# Refs of workbench: main(B)
+# git push         :            refs/tags/test-v1(B)
+test_expect_success "need proc-receive to create new tag" '
+	test_must_fail git -C test-config push \
+		origin $A:refs/tags/test-v1 >actual 2>&1 &&
+	grep "fail to run proc-receive hook" actual
+'
+
+# Refs of upstream : main(B)
+# Refs of workbench: main(B)
+# git push                      refs/pull/123/head(A)
+test_expect_success "need proc-receive to push refs/pull/123/head" '
+	test_must_fail git -C test-config push -f \
+		origin $A:refs/pull/123/head >actual 2>&1 &&
+	grep "fail to run proc-receive hook" actual
+'
+
+# Refs of upstream : main(B)  refs/pull/123/head(B)  refs/tags/test-v1
+# Refs of workbench: main(B)
+# git push                                                                 refs/for/main/topic1
+test_expect_success "need proc-receive to push refs/for/main/topic" '
+	test_must_fail git -C test-config push \
+		origin $A:refs/for/main/topic >actual 2>&1 &&
+	grep "fail to run proc-receive hook" actual
+'
-- 
patchwork
