From 32967b5b31e6d16df9e17b232cb77eabe4dbf546 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E7=82=BD=E5=A4=A9?= <hanxin.hx@alibaba-inc.com>
Date: Tue, 29 Dec 2020 15:38:43 +0800
Subject: [PATCH 31/47] crypto: add encrypt/decrypt support for loose objects

Changes to support encrypt for loose objects:

 * sha1-file.c (object-file.c in git 2.31.0 and above)

   - write_loose_object()

Changes to support decrypt for loose objects:

 * sha1-file.c (renamed as object-file.c in new version)

   - unpack_loose_short_header()
   - unpack_loose_header_to_strbuf()
   - unpack_loose_rest()
   - check_stream_oid()

 * streaming.c (decrypt using git_zstream.cryptor)

   - open_istream_loose()
   - read_method_decl(loose)

Signed-off-by: Han Xin <hanxin.hx@alibaba-inc.com>
Signed-off-by: Jiang Xin <zhiyou.jx@alibaba-inc.com>
---
 cache.h                                      |   1 +
 config.c                                     |   5 +
 environment.c                                |   1 +
 object-file.c                                |  35 +++
 t/t0940/test-0010-read-write-loose-object.sh | 297 +++++++++++++++++++
 5 files changed, 339 insertions(+)
 create mode 100644 t/t0940/test-0010-read-write-loose-object.sh

diff --git a/cache.h b/cache.h
index 6996d15a73..19c0ab7a15 100644
--- a/cache.h
+++ b/cache.h
@@ -973,6 +973,7 @@ extern int pack_compression_level;
 extern size_t packed_git_window_size;
 extern size_t packed_git_limit;
 extern size_t delta_base_cache_limit;
+extern unsigned long big_file_no_encrypt_threshold;
 extern unsigned long big_file_threshold;
 extern unsigned long pack_size_limit_cfg;
 
diff --git a/config.c b/config.c
index 0d02d26404..dfb3f83408 100644
--- a/config.c
+++ b/config.c
@@ -1920,6 +1920,11 @@ int git_default_agit_config(const char *var, const char *value, void *cb)
 		return 0;
 	}
 
+	if (!strcmp(var, "agit.crypto.bigfilenoencryptthreshold")) {
+		big_file_no_encrypt_threshold = git_config_ulong(var, value);
+		return 0;
+	}
+
 	return 0;
 }
 
diff --git a/environment.c b/environment.c
index b3296ce7d1..2684cf1b7e 100644
--- a/environment.c
+++ b/environment.c
@@ -49,6 +49,7 @@ enum fsync_component fsync_components = FSYNC_COMPONENTS_DEFAULT;
 size_t packed_git_window_size = DEFAULT_PACKED_GIT_WINDOW_SIZE;
 size_t packed_git_limit = DEFAULT_PACKED_GIT_LIMIT;
 size_t delta_base_cache_limit = 96 * 1024 * 1024;
+unsigned long big_file_no_encrypt_threshold = 10 * 1024 * 1024;
 unsigned long big_file_threshold = 512 * 1024 * 1024;
 int pager_use_color = 1;
 const char *editor_program;
diff --git a/object-file.c b/object-file.c
index b5d1d12b68..d2b29081ca 100644
--- a/object-file.c
+++ b/object-file.c
@@ -1256,6 +1256,18 @@ enum unpack_loose_header_result unpack_loose_header(git_zstream *stream,
 
 	/* Get the data stream */
 	memset(stream, 0, sizeof(*stream));
+
+	if (mapsize > GIT_CRYPTO_LO_HEADER_SIZE &&
+	    git_crypto_lo_has_signature(map)) {
+		git_cryptor *cryptor = xmalloc(sizeof(struct git_cryptor));
+
+		git_decryptor_init_or_die(cryptor, *(uint32_t *)(map + 4),
+					  map + 8);
+		map += GIT_CRYPTO_LO_HEADER_SIZE;
+		mapsize -= GIT_CRYPTO_LO_HEADER_SIZE;
+		stream->cryptor = cryptor;
+	}
+
 	stream->next_in = map;
 	stream->avail_in = mapsize;
 	stream->next_out = buffer;
@@ -1431,6 +1443,7 @@ static int loose_object_info(struct repository *r,
 	enum object_type type_scratch;
 	int allow_unknown = flags & OBJECT_INFO_ALLOW_UNKNOWN_TYPE;
 
+	memset(&stream, 0, sizeof(stream));
 	if (oi->delta_base_oid)
 		oidclr(oi->delta_base_oid);
 
@@ -1495,6 +1508,7 @@ static int loose_object_info(struct repository *r,
 	git_inflate_end(&stream);
 cleanup:
 	munmap(map, mapsize);
+	free(stream.cryptor);
 	if (oi->sizep == &size_scratch)
 		oi->sizep = NULL;
 	strbuf_release(&hdrbuf);
@@ -1960,6 +1974,12 @@ static int write_loose_object(const struct object_id *oid, char *hdr,
 	struct object_id parano_oid;
 	static struct strbuf tmp_file = STRBUF_INIT;
 	static struct strbuf filename = STRBUF_INIT;
+	git_cryptor cryptor;
+	unsigned char *git_cryptor_header = NULL;
+	int do_encrypt = 0;
+
+	if (agit_crypto_enabled && len < big_file_no_encrypt_threshold)
+		do_encrypt = 1;
 
 	loose_object_path(the_repository, &filename, oid);
 
@@ -1973,10 +1993,22 @@ static int write_loose_object(const struct object_id *oid, char *hdr,
 			return error_errno(_("unable to create temporary file"));
 	}
 
+	if (do_encrypt) {
+		git_encryptor_init_for_loose_object(&cryptor);
+		git_cryptor_header =
+			git_encryptor_get_net_object_header(&cryptor, NULL);
+		if (write_buffer(fd, git_cryptor_header,
+				 GIT_CRYPTO_LO_HEADER_SIZE) < 0)
+			die(_("unable to write loose object file"));
+		free(git_cryptor_header);
+	}
+
 	/* Set it up */
 	git_deflate_init(&stream, zlib_compression_level);
 	stream.next_out = compressed;
 	stream.avail_out = sizeof(compressed);
+	if (do_encrypt)
+		stream.cryptor = &cryptor;
 	the_hash_algo->init_fn(&c);
 
 	/* First header.. */
@@ -2617,6 +2649,8 @@ int read_loose_object(const char *path,
 	char hdr[MAX_HEADER_LEN];
 	unsigned long *size = oi->sizep;
 
+	memset(&stream, 0, sizeof(stream));
+
 	map = map_loose_object_1(the_repository, path, NULL, &mapsize);
 	if (!map) {
 		error_errno(_("unable to mmap %s"), path);
@@ -2661,5 +2695,6 @@ int read_loose_object(const char *path,
 out:
 	if (map)
 		munmap(map, mapsize);
+	free(stream.cryptor);
 	return ret;
 }
diff --git a/t/t0940/test-0010-read-write-loose-object.sh b/t/t0940/test-0010-read-write-loose-object.sh
new file mode 100644
index 0000000000..a254346a01
--- /dev/null
+++ b/t/t0940/test-0010-read-write-loose-object.sh
@@ -0,0 +1,297 @@
+#!/bin/sh
+
+# Test encrypted loose object
+
+test_expect_success 'create small text file: blob-foo' '
+	cat >blob-foo <<-\EOF
+	demo
+	EOF
+'
+
+test_expect_success 'create normal blob object from blob-foo' '
+	oid=$(git hash-object -t blob -w blob-foo) &&
+	test -f .git/objects/${oid%${oid#??}}/${oid#??} &&
+	test_copy_bytes 2 <.git/objects/${oid%${oid#??}}/${oid#??} |
+		test-tool agit-od >actual &&
+	cat >expect <<-EOF &&
+	0000000 78 01                                              | x.               |
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success 'verify normal blob object' '
+	git cat-file -p $oid >actual &&
+	test_cmp blob-foo actual
+'
+
+test_expect_success 'create commit c1 with blob-bar' '
+	git add blob-foo &&
+	test_tick &&
+	git commit -m blob-foo &&
+	c1=$(git rev-parse HEAD)
+'
+
+test_expect_success 'same oid for commit c1' '
+	cat >expect <<-EOF &&
+	$oid
+	EOF
+	git rev-parse $c1:blob-foo >actual &&
+	test_cmp expect actual
+'
+
+test_expect_success 'check object header for commit c1' '
+	test_copy_bytes 2 <.git/objects/${c1%${c1#??}}/${c1#??} |
+		test-tool agit-od >actual &&
+	cat >expect <<-EOF &&
+	0000000 78 01                                              | x.               |
+	EOF
+	test_cmp expect actual
+'
+
+test_expect_success 'fsck on loose objects before encryption' '
+	git fsck --strict
+'
+
+test_expect_success 'turn on agit.crypto settings' '
+	git config agit.crypto.enabled 1 &&
+	git config agit.crypto.secret c2VjcmV0LXRva2VuMTIzNA== &&
+	git config agit.crypto.nonce random_nonce
+'
+
+# algorithm: benchmark
+cat >expect-hdr-1 <<-EOF
+0000000 45 4e 43 00 81 00 00 00 72 61 6e 64 6f 6d 5f 6e    | ENC.....random_n |
+0000016 6f 6e 63 65                                        | once             |
+EOF
+
+# algorithm: aes
+cat >expect-hdr-2 <<-EOF
+0000000 45 4e 43 00 82 00 00 00 72 61 6e 64 6f 6d 5f 6e    | ENC.....random_n |
+0000016 6f 6e 63 65                                        | once             |
+EOF
+
+# algorithm: easy_benchmark
+cat >expect-hdr-64 <<-EOF
+0000000 45 4e 43 00 c0 00 00 00 72 61 6e 64 6f 6d 5f 6e    | ENC.....random_n |
+0000016 6f 6e 63 65                                        | once             |
+EOF
+
+# algorithm: easy_aes
+cat >expect-hdr-65 <<-EOF
+0000000 45 4e 43 00 c1 00 00 00 72 61 6e 64 6f 6d 5f 6e    | ENC.....random_n |
+0000016 6f 6e 63 65                                        | once             |
+EOF
+
+test_expect_success 'create small text file: blob-bar' '
+	cat >blob-bar <<-\EOF
+	hello, world
+	EOF
+'
+
+test_expect_success 'create small encrypted blob object from blob-bar' '
+	oid=$(git hash-object -t blob -w blob-bar) &&
+	test -f .git/objects/${oid%${oid#??}}/${oid#??} &&
+	show_lo_header <.git/objects/${oid%${oid#??}}/${oid#??} |
+		test-tool agit-od >actual &&
+	test_cmp expect-hdr-${GIT_TEST_CRYPTO_ALGORITHM_TYPE} actual
+'
+
+test_expect_success 'fail to restore encrypted blob object with bad token' '
+	test_must_fail git -c agit.crypto.secret=bad-token \
+		cat-file -p $oid
+'
+
+test_expect_success 'verify encrypted blob object for blob-bar' '
+	git cat-file -p $oid >actual &&
+	test_cmp blob-bar actual
+'
+
+test_expect_success 'create commit c2 with blob-bar' '
+	git add blob-bar &&
+	test_tick &&
+	git commit -m blob-bar &&
+	c2=$(git rev-parse HEAD)
+'
+
+test_expect_success 'same oid for commit c2' '
+	cat >expect <<-EOF &&
+	$oid
+	EOF
+	git rev-parse $c2:blob-bar >actual &&
+	test_cmp expect actual
+'
+
+test_expect_success 'check object header for commit c2' '
+	show_lo_header <.git/objects/${c2%${c2#??}}/${c2#??} |
+		test-tool agit-od >actual &&
+	test_cmp expect-hdr-${GIT_TEST_CRYPTO_ALGORITHM_TYPE} actual
+'
+
+test_expect_success NEED_GNU_DD 'create small binary file: blob-2m' '
+	cat >blob-2m <<-\EOF &&
+	blob-2m, which is smaller than 10MB (GIT_CRYPTO_ENCRYPT_LO_MAX_SIZE), will save to
+	encrypted loose object.
+	EOF
+	if type openssl
+	then
+		openssl enc -aes-256-ctr \
+			-pass pass:"$($DD if=/dev/urandom bs=128 count=1 2>/dev/null | base64)" \
+			-nosalt < /dev/zero | $DD bs=1024 count=2050 >>blob-2m
+	else
+		$DD if=/dev/random bs=1024 count=2050 >>blob-2m
+	fi
+'
+
+test_expect_success NEED_GNU_DD 'create encrypted blob object from blob-2m' '
+	oid=$(git hash-object -t blob -w blob-2m) &&
+	test -f .git/objects/${oid%${oid#??}}/${oid#??} &&
+	show_lo_header <.git/objects/${oid%${oid#??}}/${oid#??} |
+		test-tool agit-od >actual &&
+	test_cmp expect-hdr-${GIT_TEST_CRYPTO_ALGORITHM_TYPE} actual
+'
+
+test_expect_success NEED_GNU_DD 'verify encrypted large blob object from blob-2m' '
+	git cat-file -p $oid >actual &&
+	test_cmp blob-2m actual
+'
+
+test_expect_success NEED_GNU_DD 'create commit c3 with blob-2m' '
+	git add blob-2m &&
+	test_tick &&
+	git commit -m blob-2m &&
+	c3=$(git rev-parse HEAD)
+'
+
+test_expect_success NEED_GNU_DD 'same oid for commit c3' '
+	cat >expect <<-EOF &&
+	$oid
+	EOF
+	git rev-parse $c3:blob-2m >actual &&
+	test_cmp expect actual
+'
+
+test_expect_success NEED_GNU_DD 'check object header for commit c3' '
+	show_lo_header <.git/objects/${c3%${c3#??}}/${c3#??} |
+		test-tool agit-od >actual &&
+	test_cmp expect-hdr-${GIT_TEST_CRYPTO_ALGORITHM_TYPE} actual
+'
+
+test_expect_success NEED_GNU_DD 'create blob-11m, which larger than GIT_CRYPTO_ENCRYPT_LO_MAX_SIZE)' '
+	cat >blob-11m <<-\EOF &&
+	blob-11m, which is larger than GIT_CRYPTO_ENCRYPT_LO_MAX_SIZE, will save to
+	loose object without encryption.
+	EOF
+	if type openssl
+	then
+		openssl enc -aes-256-ctr \
+			-pass pass:"$($DD if=/dev/urandom bs=128 count=1 2>/dev/null | base64)" \
+			-nosalt < /dev/zero | $DD bs=1024 count=11234 >>blob-11m 
+	else
+		$DD if=/dev/random bs=1024 count=11234 >>blob-11m 
+	fi
+'
+
+cat >expect <<-EOF
+0000000 78 01 00                                           | x..              |
+EOF
+
+test_expect_success NEED_GNU_DD 'not encrypt large file: blob-11m' '
+	oid=$(git hash-object -t blob -w blob-11m) &&
+	test -f .git/objects/${oid%${oid#??}}/${oid#??} &&
+	test_copy_bytes 3 <.git/objects/${oid%${oid#??}}/${oid#??} |
+		test-tool agit-od >actual &&
+	test_cmp expect actual
+'
+
+test_expect_success NEED_GNU_DD 'verify un-encrypted large blob object: blob-11m' '
+	git cat-file -p $oid >actual &&
+	test_cmp blob-11m actual
+'
+
+test_expect_success NEED_GNU_DD 'create commit c4 with blob-11m' '
+	git add blob-11m &&
+	test_tick &&
+	git commit -m blob-11m &&
+	c4=$(git rev-parse HEAD)
+'
+
+test_expect_success NEED_GNU_DD 'same oid for commit c4' '
+	cat >expect <<-EOF &&
+	$oid
+	EOF
+	git rev-parse $c4:blob-11m >actual &&
+	test_cmp expect actual
+'
+
+test_expect_success NEED_GNU_DD 'check object header for commit c4' '
+	show_lo_header <.git/objects/${c4%${c4#??}}/${c4#??} |
+		test-tool agit-od >actual &&
+	test_cmp expect-hdr-${GIT_TEST_CRYPTO_ALGORITHM_TYPE} actual
+'
+
+test_expect_success NEED_GNU_DD 'change core.bigfilethreshold from 512MB (default) to 3MB' '
+	git config core.bigfilethreshold 3000000
+'
+
+test_expect_success NEED_GNU_DD 'create blob-5m, which larger than bigfilethreshold' '
+	cat >blob-5m <<-\EOF &&
+	blob-5m, which larger than core.bigfilethreshold, and will be streamed
+	directly to packfile.
+	EOF
+	if type openssl
+	then
+		openssl enc -aes-256-ctr \
+			-pass pass:"$($DD if=/dev/urandom bs=128 count=1 2>/dev/null | base64)" \
+			-nosalt < /dev/zero | $DD bs=1024 count=5000 >>blob-5m
+	else
+		$DD if=/dev/random bs=1024 count=5000 >>blob-5m
+	fi
+'
+
+cat >expect-blob-5m <<-EOF
+0000000 50 41 43 4b 00 00 00 02                            | PACK....         |
+EOF
+
+test_expect_success NEED_GNU_DD 'large blob beyond threshold will not save as loose object' '
+	oid=$(git hash-object -t blob -w blob-5m) &&
+	test ! -f .git/objects/${oid%${oid#??}}/${oid#??} &&
+	PACKID=$(ls ".git/objects/pack/" | grep "pack$") &&
+	PACKID=${PACKID%.pack} &&
+	PACKID=${PACKID#*pack-}
+'
+
+test_expect_success NEED_GNU_DD 'large blob beyond threshold will be saved as packfile (not encrypted)' '
+	test_copy_bytes 8 <".git/objects/pack/pack-$PACKID.pack" |
+		test-tool agit-od >actual &&
+	test_cmp expect-blob-5m actual
+'
+
+test_expect_success NEED_GNU_DD 'verify blob-5m, which is larger than bigfilethreshold' '
+	git cat-file -p $oid >actual &&
+	test_cmp blob-5m actual
+'
+
+test_expect_success NEED_GNU_DD 'create commit c5 with blob-5m' '
+	git add blob-5m &&
+	test_tick &&
+	git commit -m blob-5m &&
+	c5=$(git rev-parse HEAD)
+'
+
+test_expect_success NEED_GNU_DD 'same oid for commit c5' '
+	cat >expect <<-EOF &&
+	$oid
+	EOF
+	git rev-parse $c5:blob-5m >actual &&
+	test_cmp expect actual
+'
+
+test_expect_success NEED_GNU_DD 'check object header for commit c5' '
+	show_lo_header <.git/objects/${c5%${c5#??}}/${c5#??} |
+		test-tool agit-od >actual &&
+	test_cmp expect-hdr-${GIT_TEST_CRYPTO_ALGORITHM_TYPE} actual
+'
+
+test_expect_success NEED_GNU_DD 'fsck on loose objects' '
+	git fsck --strict
+'
-- 
patchwork
